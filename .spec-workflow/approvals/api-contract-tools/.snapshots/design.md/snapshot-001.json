{
  "id": "snapshot_1766194334604_1al6zz2q8",
  "approvalId": "approval_1766194334554_k8h4b45to",
  "approvalTitle": "Design Document - API Contract Tools",
  "version": 1,
  "timestamp": "2025-12-20T01:32:14.604Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Design Document\n\n## Overview\n\nThe API Contract Tools feature adds four new MCP tools to the aegisx-mcp server that enable programmatic access to API contract documentation stored in `docs/features/*/api-contracts.md` files. This feature follows the existing aegisx-mcp architecture pattern established by the components, CRUD, and patterns tools.\n\nThe implementation will consist of:\n1. **API Contract Parser** - Extracts structured data from markdown contract files\n2. **MCP Tool Handlers** - Implements the four core tools (list, search, get, validate)\n3. **Server Registration** - Registers tools in the main MCP server with Zod schemas\n4. **Data Layer** - Manages caching and file system access\n\nThis design aligns with the project's API-First development philosophy by making API contracts discoverable and verifiable through structured tooling.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n\nThis feature follows established technical patterns:\n- **TypeScript** for all implementation code\n- **Zod** for MCP tool parameter validation\n- **Model Context Protocol SDK** for server implementation\n- **File System Access** using Node.js `fs` module with proper error handling\n- **Markdown Parsing** using pattern matching and regex for structure extraction\n\n### Project Structure (structure.md)\n\nFiles will be organized following the existing aegisx-mcp structure:\n```\nlibs/aegisx-mcp/src/\n├── tools/\n│   ├── api-contracts.tool.ts (NEW - handler functions)\n│   └── index.ts (UPDATED - export new handlers)\n├── data/\n│   └── api-contracts-parser.ts (NEW - parsing logic)\n└── index.ts (UPDATED - register new MCP tools)\n```\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n\n- **MCP Server Infrastructure** (`src/index.ts`): Reuse existing server setup, tool registration pattern, and Zod schema validation approach\n- **Tool Handler Pattern** (`src/tools/components.tool.ts`): Follow the same handler function structure with switch-case for different operations\n- **Data Layer Pattern** (`src/data/components.ts`): Apply similar data structure design with TypeScript interfaces and helper functions\n- **File System Utilities**: Use Node.js `fs.promises` for async file operations (already used in the project)\n\n### Integration Points\n\n- **aegisx-mcp Server**: New tools will be registered alongside existing tools (components, CRUD, patterns) in `src/index.ts`\n- **Documentation Structure**: Parser will read from `docs/features/*/api-contracts.md` following the established documentation conventions\n- **Error Handling**: Will use the same error response pattern as existing tools (return helpful error messages in text format)\n\n## Architecture\n\nThe architecture follows a **layered design** with clear separation of concerns:\n\n```mermaid\ngraph TD\n    A[MCP Client/AI Agent] -->|Tool Call| B[MCP Server index.ts]\n    B -->|Route| C[API Contracts Tool Handler]\n    C -->|Parse Request| D[Contract Parser]\n    D -->|Read Files| E[File System docs/features/]\n    D -->|Cache| F[In-Memory Cache]\n    C -->|Format Response| G[Text Response]\n    G -->|Return| A\n```\n\n### Modular Design Principles\n\n- **Single File Responsibility**:\n  - `api-contracts.tool.ts` - Handles MCP tool routing and response formatting\n  - `api-contracts-parser.ts` - Handles markdown parsing and data extraction\n  - `index.ts` - Registers tools with MCP server\n\n- **Component Isolation**:\n  - Parser is completely independent of MCP tool handlers\n  - Can be tested separately\n  - Can be reused for other purposes (CLI tools, documentation generators, etc.)\n\n- **Service Layer Separation**:\n  - **MCP Layer** (`index.ts`) - Tool registration and schema validation\n  - **Handler Layer** (`api-contracts.tool.ts`) - Business logic and response formatting\n  - **Data Layer** (`api-contracts-parser.ts`) - File I/O and parsing\n\n- **Utility Modularity**:\n  - Parser functions are small and focused (parseContract, extractEndpoints, etc.)\n  - Each function has a single responsibility\n\n## Components and Interfaces\n\n### Component 1: API Contract Parser\n\n**Purpose**: Parse markdown API contract files and extract structured endpoint data\n\n**Interfaces**:\n```typescript\nexport interface ApiEndpoint {\n  method: 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';\n  path: string;\n  description: string;\n  feature: string; // e.g., \"user-profile\", \"rbac\"\n  authentication: boolean;\n  requestSchema?: string; // Code block content\n  responseSchema?: string; // Code block content\n  requestExample?: string;\n  responseExample?: string;\n  errorResponses?: Array<{\n    statusCode: number;\n    description: string;\n    example?: string;\n  }>;\n}\n\nexport interface ApiContract {\n  feature: string;\n  baseUrl: string;\n  authentication: string;\n  contentType: string;\n  endpoints: ApiEndpoint[];\n  filePath: string;\n}\n\n// Main parser functions\nexport function parseContractFile(filePath: string): Promise<ApiContract>;\nexport function getAllContracts(rootPath: string): Promise<ApiContract[]>;\nexport function searchEndpoints(contracts: ApiContract[], query: string): ApiEndpoint[];\nexport function findEndpoint(contracts: ApiContract[], path: string, method?: string): ApiEndpoint | null;\n```\n\n**Dependencies**:\n- Node.js `fs.promises` for file reading\n- Path utilities for file path resolution\n\n**Reuses**: Standard Node.js APIs, no project-specific utilities needed\n\n### Component 2: MCP Tool Handler\n\n**Purpose**: Implement the four MCP tools with proper request handling and response formatting\n\n**Interfaces**:\n```typescript\nexport function handleApiContractTool(\n  name: string,\n  args: Record<string, unknown>\n): { content: Array<{ type: string; text: string }> };\n\n// Internal formatting functions\nfunction formatEndpointBrief(endpoint: ApiEndpoint): string;\nfunction formatEndpointDetail(endpoint: ApiEndpoint): string;\nfunction formatContractList(contracts: ApiContract[]): string;\nfunction formatValidationReport(report: ValidationReport): string;\n```\n\n**Dependencies**:\n- API Contract Parser for data access\n- Cache manager (if implemented)\n\n**Reuses**: Parser component for all data access\n\n### Component 3: Validation Logic\n\n**Purpose**: Compare documented endpoints with actual route implementations\n\n**Interfaces**:\n```typescript\nexport interface ValidationReport {\n  feature: string;\n  matched: number;\n  missing: Array<{\n    method: string;\n    path: string;\n    expectedFile: string;\n  }>;\n  undocumented: Array<{\n    method: string;\n    path: string;\n    foundIn: string;\n  }>;\n  methodMismatches: Array<{\n    path: string;\n    documentedMethod: string;\n    implementedMethod: string;\n    file: string;\n  }>;\n}\n\nexport function validateFeature(\n  contracts: ApiContract[],\n  feature: string,\n  codebaseRoot: string\n): Promise<ValidationReport>;\n```\n\n**Dependencies**:\n- Glob/grep for searching route files\n- Parser for contract data\n\n**Reuses**: Parser component, file system utilities\n\n## Data Models\n\n### ApiEndpoint Model\n```typescript\ninterface ApiEndpoint {\n  method: 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';\n  path: string;                    // e.g., \"/api/profile\"\n  description: string;             // Brief description of what endpoint does\n  feature: string;                 // Feature name (e.g., \"user-profile\")\n  authentication: boolean;         // Whether auth is required\n  requestSchema?: string;          // TypeScript interface or JSON schema\n  responseSchema?: string;         // TypeScript interface or JSON schema\n  requestExample?: string;         // Example request (bash/curl/json)\n  responseExample?: string;        // Example response (json)\n  errorResponses?: ErrorResponse[];\n}\n\ninterface ErrorResponse {\n  statusCode: number;              // HTTP status code (401, 404, 500, etc.)\n  description: string;             // Error description\n  example?: string;                // Example error response JSON\n}\n```\n\n### ApiContract Model\n```typescript\ninterface ApiContract {\n  feature: string;                 // Feature name from directory\n  baseUrl: string;                 // Base URL prefix (e.g., \"/api/profile\")\n  authentication: string;          // Auth requirements description\n  contentType: string;             // Content-Type header\n  endpoints: ApiEndpoint[];        // All endpoints in this contract\n  filePath: string;                // Path to contract file\n}\n```\n\n### ValidationReport Model\n```typescript\ninterface ValidationReport {\n  feature: string;                 // Feature being validated\n  matched: number;                 // Number of matching endpoints\n  missing: MissingEndpoint[];      // Documented but not implemented\n  undocumented: UndocumentedEndpoint[]; // Implemented but not documented\n  methodMismatches: MethodMismatch[];   // Wrong HTTP methods\n}\n\ninterface MissingEndpoint {\n  method: string;                  // Expected HTTP method\n  path: string;                    // Expected path\n  expectedFile: string;            // Where it should be implemented\n}\n\ninterface UndocumentedEndpoint {\n  method: string;                  // Found HTTP method\n  path: string;                    // Found path\n  foundIn: string;                 // File where it was found\n}\n\ninterface MethodMismatch {\n  path: string;                    // Endpoint path\n  documentedMethod: string;        // Method in contract\n  implementedMethod: string;       // Method in code\n  file: string;                    // File with implementation\n}\n```\n\n## Error Handling\n\n### Error Scenarios\n\n1. **Contract File Not Found**\n   - **Handling**: Return empty contract with warning message\n   - **User Impact**: Tool shows \"No contracts found\" with helpful message suggesting feature names\n\n2. **Malformed Markdown**\n   - **Handling**: Parser attempts to extract available information, logs warnings for malformed sections\n   - **User Impact**: Partial data returned with note about parsing issues\n\n3. **Invalid Endpoint Path**\n   - **Handling**: Return error with suggestion for similar endpoints\n   - **User Impact**: Helpful error: \"Endpoint '/api/users' not found. Did you mean '/api/profile'?\"\n\n4. **Empty Search Results**\n   - **Handling**: Return empty array with suggestion to try different terms\n   - **User Impact**: \"No endpoints found matching 'xyz'. Try searching for 'budget', 'user', or 'auth'\"\n\n5. **Validation Errors (File Access)**\n   - **Handling**: Skip inaccessible files, continue validating remaining features\n   - **User Impact**: Validation report shows which features were checked and which were skipped\n\n6. **Invalid Tool Parameters**\n   - **Handling**: Zod validation catches at MCP layer before reaching handler\n   - **User Impact**: Clear validation error from MCP server\n\n## Testing Strategy\n\n### Unit Testing\n\n**Parser Tests** (`api-contracts-parser.test.ts`):\n- Test parsing valid contract markdown\n- Test handling malformed markdown gracefully\n- Test extracting endpoints with all fields\n- Test extracting endpoints with missing optional fields\n- Test searching endpoints by different criteria\n- Test finding endpoints by path and method\n\n**Tool Handler Tests** (`api-contracts.tool.test.ts`):\n- Test each tool (list, search, get, validate) with valid inputs\n- Test error handling for invalid inputs\n- Test response formatting\n- Test empty result scenarios\n\n### Integration Testing\n\n**End-to-End MCP Tests**:\n- Test full MCP tool call flow (client → server → parser → response)\n- Test with real contract files from `docs/features/`\n- Test caching behavior (if implemented)\n- Test concurrent requests\n\n**Validation Tests**:\n- Test validation against real codebase\n- Test detection of missing endpoints\n- Test detection of undocumented endpoints\n- Test detection of method mismatches\n\n### End-to-End Testing\n\n**Real-World Scenarios**:\n1. AI agent searches for budget-related endpoints\n2. AI agent retrieves contract for specific endpoint to implement frontend\n3. AI agent validates implementation matches contract\n4. AI agent discovers all available APIs before starting feature work\n\n**Test Data**:\n- Use existing `docs/features/*/api-contracts.md` files\n- Create test contract files with known endpoints\n- Create test route files with known implementations\n",
  "fileStats": {
    "size": 12170,
    "lines": 339,
    "lastModified": "2025-12-20T01:32:05.616Z"
  },
  "comments": []
}
