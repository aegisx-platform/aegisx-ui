{
  "id": "snapshot_1766101212419_b7i1swuty",
  "approvalId": "approval_1766101212343_vsfup8bzp",
  "approvalTitle": "Design Document - Inventory UI Components (Priority 2)",
  "version": 1,
  "timestamp": "2025-12-18T23:40:12.419Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Design Document - Inventory UI Components (Priority 2)\n\n## Introduction\n\nThis design document details the UI/UX, component architecture, and technical implementation for the six Priority 2 inventory components: **Stock Movement Timeline**, **Expiry Date Badge**, **Product Variant Selector**, **Stock Alert Panel**, **Inventory Transfer Wizard**, and **Location/Warehouse Picker**.\n\nThese components follow AegisX UI design principles:\n- Material Design 3 guidelines\n- Angular standalone component architecture\n- Signal-based reactive patterns\n- TypeScript strict mode with comprehensive type safety\n- WCAG 2.1 AA accessibility compliance\n- Integration with Priority 1 components\n\n---\n\n## 1. Stock Movement Timeline (`ax-stock-movement-timeline`)\n\n### 1.1 Visual Design\n\n#### Layout Structure\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  Stock Movement History - Product: Aspirin 500mg           â”‚\nâ”‚  [Filter: All Types â–¼] [Group: Day â–¼] [ğŸ“… Date Range]     â”‚\nâ”‚  [ğŸ“Š Balance Chart] [ğŸ“„ Export]                            â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚                                                             â”‚\nâ”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€ Balance Line Chart â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”‚\nâ”‚  â”‚   500 â”¤                        â•±â”€  â”‚                    â”‚\nâ”‚  â”‚       â”‚                    â•±â”€â”€â”€    â”‚                    â”‚\nâ”‚  â”‚   250 â”¤              â•±â”€â”€â”€â”€â”€        â”‚                    â”‚\nâ”‚  â”‚       â”‚       â•±â”€â”€â”€â”€â”€â”€              â”‚                    â”‚\nâ”‚  â”‚     0 â”¤â”€â”€â”€â”€â”€â”€â”€                     â”‚                    â”‚\nâ”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â”‚\nâ”‚                                                             â”‚\nâ”‚  ğŸ“… December 18, 2025 (Total: +150)                        â”‚\nâ”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚\nâ”‚  â”‚ 14:30  [IN] Receive            +100 â†’ Balance: 450  â”‚   â”‚\nâ”‚  â”‚        PO-2025-001 | John Doe                       â”‚   â”‚\nâ”‚  â”‚        ğŸ“¦ Batch: BATCH-2024-001                     â”‚   â”‚\nâ”‚  â”‚        [Click to expand â–¼]                          â”‚   â”‚\nâ”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚\nâ”‚  â”‚ 10:15  [OUT] Issue              -50 â†’ Balance: 350  â”‚   â”‚\nâ”‚  â”‚        SO-2025-042 | Jane Smith                     â”‚   â”‚\nâ”‚  â”‚        ğŸ“¦ Batch: BATCH-2024-001                     â”‚   â”‚\nâ”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚\nâ”‚                                                             â”‚\nâ”‚  ğŸ“… December 17, 2025 (Total: -25)                         â”‚\nâ”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚\nâ”‚  â”‚ 16:45  [ADJUST] Stock Count     -25 â†’ Balance: 400  â”‚   â”‚\nâ”‚  â”‚        ADJ-2025-012 | Admin                         â”‚   â”‚\nâ”‚  â”‚        ğŸ“ Note: Physical count discrepancy          â”‚   â”‚\nâ”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚\nâ”‚                                                             â”‚\nâ”‚  [Load More...]                                            â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n#### Color Scheme\n- **Movement types**:\n  - IN (Receive): `text-success-700` with `bg-success-50` background\n  - OUT (Issue): `text-error-700` with `bg-error-50` background\n  - TRANSFER-IN: `text-blue-700` with `bg-blue-50` background\n  - TRANSFER-OUT: `text-blue-700` with `bg-blue-50` background\n  - ADJUST: `text-warning-700` with `bg-warning-50` background\n- **Balance chart**: `stroke-primary-500` line, `fill-primary-100` area\n- **Card borders**: `border-default` with hover effect\n- **Expanded state**: `bg-muted` background\n\n#### Typography\n- **Header**: `text-lg font-semibold text-primary`\n- **Date group**: `text-base font-medium text-secondary`\n- **Movement time**: `text-sm font-medium text-primary`\n- **Movement type**: `text-xs font-bold uppercase`\n- **Balance**: `text-base font-semibold text-primary`\n- **User/document**: `text-sm text-subtle`\n- **Notes**: `text-xs text-secondary italic`\n\n#### Spacing\n- Container padding: `p-4`\n- Gap between movements: `gap-2`\n- Card padding: `p-3`\n- Date group margin: `mt-6 mb-2`\n- Chart height: 200px\n\n### 1.2 Component Architecture\n\n#### Component Structure\n```typescript\nAxStockMovementTimelineComponent\nâ”œâ”€â”€ Template\nâ”‚   â”œâ”€â”€ Header section\nâ”‚   â”‚   â”œâ”€â”€ Product info display\nâ”‚   â”‚   â”œâ”€â”€ Filter controls (type, date range)\nâ”‚   â”‚   â”œâ”€â”€ Group by selector\nâ”‚   â”‚   â””â”€â”€ Export button\nâ”‚   â”œâ”€â”€ Balance chart section (Chart.js canvas)\nâ”‚   â”œâ”€â”€ Movements section\nâ”‚   â”‚   â””â”€â”€ Date groups (repeated)\nâ”‚   â”‚       â””â”€â”€ Movement cards (repeated)\nâ”‚   â”‚           â”œâ”€â”€ Time + type badge\nâ”‚   â”‚           â”œâ”€â”€ Quantity + balance\nâ”‚   â”‚           â”œâ”€â”€ User + document\nâ”‚   â”‚           â””â”€â”€ Expandable details\nâ”‚   â”œâ”€â”€ Loading state (skeleton loader)\nâ”‚   â”œâ”€â”€ Empty state (\"No movements found\")\nâ”‚   â””â”€â”€ Load more button\nâ””â”€â”€ State Management\n    â”œâ”€â”€ movements (signal: MovementRecord[])\n    â”œâ”€â”€ filteredMovements (computed)\n    â”œâ”€â”€ groupedMovements (computed)\n    â”œâ”€â”€ balanceData (computed for chart)\n    â”œâ”€â”€ filters (signal: MovementFilter)\n    â”œâ”€â”€ expandedIds (signal: Set<string>)\n    â””â”€â”€ isLoading (signal: boolean)\n```\n\n#### State Management (Signals)\n```typescript\n// Inputs\nproductId = input.required<string>();\nmovements = input<MovementRecord[]>([]);\ngroupBy = model<'none' | 'day' | 'week' | 'month'>('none');\nshowBalance = input<boolean>(true);\nshowFilters = input<boolean>(true);\nenableExport = input<boolean>(true);\nenableRealtime = input<boolean>(false);\ndateRange = input<{ start: Date, end: Date } | undefined>(undefined);\npageSize = input<number>(50);\n\n// Outputs\nonMovementClick = output<MovementRecord>();\nonExport = output<{ format: 'pdf' | 'excel', data: MovementRecord[] }>();\nonFilterChange = output<MovementFilter>();\nonMovementsLoad = output<MovementRecord[]>();\n\n// Internal state\nprivate internalMovements = signal<MovementRecord[]>([]);\nprivate filters = signal<MovementFilter>({ types: [] });\nprivate expandedIds = signal<Set<string>>(new Set());\nprivate isLoading = signal<boolean>(false);\nprivate currentPage = signal<number>(0);\n\n// Computed\nfilteredMovements = computed(() => {\n  let movements = this.internalMovements();\n  const filter = this.filters();\n\n  if (filter.types && filter.types.length > 0) {\n    movements = movements.filter(m => filter.types!.includes(m.type));\n  }\n\n  if (filter.dateRange) {\n    const { start, end } = filter.dateRange;\n    movements = movements.filter(m =>\n      m.timestamp >= start && m.timestamp <= end\n    );\n  }\n\n  return movements;\n});\n\ngroupedMovements = computed(() => {\n  const movements = this.filteredMovements();\n  const grouping = this.groupBy();\n\n  if (grouping === 'none') {\n    return [{ key: 'all', date: null, movements, total: 0 }];\n  }\n\n  const groups = new Map<string, MovementRecord[]>();\n\n  movements.forEach(m => {\n    const key = this.getGroupKey(m.timestamp, grouping);\n    if (!groups.has(key)) {\n      groups.set(key, []);\n    }\n    groups.get(key)!.push(m);\n  });\n\n  return Array.from(groups.entries()).map(([key, movements]) => ({\n    key,\n    date: movements[0]?.timestamp,\n    movements,\n    total: this.calculateNetChange(movements)\n  }));\n});\n\nbalanceData = computed(() => {\n  const movements = this.filteredMovements();\n  let runningBalance = this.getCurrentBalance() - this.getTotalChange(movements);\n\n  return movements.map(m => {\n    const change = this.getQuantityChange(m);\n    runningBalance += change;\n    return {\n      timestamp: m.timestamp,\n      balance: runningBalance\n    };\n  });\n});\n\nprivate getGroupKey(date: Date, grouping: 'day' | 'week' | 'month'): string {\n  switch (grouping) {\n    case 'day':\n      return date.toISOString().split('T')[0];\n    case 'week':\n      const weekStart = new Date(date);\n      weekStart.setDate(date.getDate() - date.getDay());\n      return weekStart.toISOString().split('T')[0];\n    case 'month':\n      return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;\n  }\n}\n\nprivate getQuantityChange(movement: MovementRecord): number {\n  const inTypes: MovementType[] = ['receive', 'transfer-in', 'adjust-in'];\n  return inTypes.includes(movement.type) ? movement.quantity : -movement.quantity;\n}\n\nprivate calculateNetChange(movements: MovementRecord[]): number {\n  return movements.reduce((sum, m) => sum + this.getQuantityChange(m), 0);\n}\n```\n\n#### Chart Integration (Chart.js)\n```typescript\nprivate readonly chartService = inject(ChartService);\n@ViewChild('chartCanvas') chartCanvas?: ElementRef<HTMLCanvasElement>;\n\nprivate chart?: Chart;\n\nngAfterViewInit() {\n  if (this.showBalance() && this.chartCanvas) {\n    this.initializeChart();\n  }\n}\n\nngOnDestroy() {\n  this.chart?.destroy();\n}\n\nprivate initializeChart() {\n  const canvas = this.chartCanvas?.nativeElement;\n  if (!canvas) return;\n\n  effect(() => {\n    const data = this.balanceData();\n    this.updateChart(data);\n  });\n}\n\nprivate updateChart(data: { timestamp: Date, balance: number }[]) {\n  if (this.chart) {\n    this.chart.destroy();\n  }\n\n  const ctx = this.chartCanvas!.nativeElement.getContext('2d')!;\n\n  this.chart = new Chart(ctx, {\n    type: 'line',\n    data: {\n      labels: data.map(d => d.timestamp),\n      datasets: [{\n        label: 'Balance',\n        data: data.map(d => d.balance),\n        borderColor: 'rgb(59, 130, 246)',\n        backgroundColor: 'rgba(59, 130, 246, 0.1)',\n        fill: true,\n        tension: 0.4\n      }]\n    },\n    options: {\n      responsive: true,\n      maintainAspectRatio: false,\n      plugins: {\n        legend: { display: false },\n        tooltip: {\n          callbacks: {\n            title: (items) => {\n              return new Date(items[0].parsed.x).toLocaleString();\n            },\n            label: (item) => {\n              return `Balance: ${item.parsed.y} pieces`;\n            }\n          }\n        }\n      },\n      scales: {\n        x: {\n          type: 'time',\n          time: { unit: 'day' },\n          display: true\n        },\n        y: {\n          beginAtZero: true,\n          display: true\n        }\n      }\n    }\n  });\n}\n```\n\n### 1.3 Technical Implementation\n\n#### API Integration\n```typescript\nprivate readonly http = inject(HttpClient);\nprivate readonly ws = inject(WebSocketService);\n\nasync ngOnInit() {\n  if (!this.movements().length && this.productId()) {\n    await this.loadMovements();\n  } else {\n    this.internalMovements.set(this.movements());\n  }\n\n  if (this.enableRealtime()) {\n    this.subscribeToUpdates();\n  }\n}\n\nprivate async loadMovements() {\n  this.isLoading.set(true);\n\n  try {\n    const params: any = {\n      limit: this.pageSize(),\n      offset: this.currentPage() * this.pageSize()\n    };\n\n    const filter = this.filters();\n    if (filter.types?.length) {\n      params.types = filter.types;\n    }\n    if (filter.dateRange) {\n      params.startDate = filter.dateRange.start.toISOString();\n      params.endDate = filter.dateRange.end.toISOString();\n    }\n\n    const response = await firstValueFrom(\n      this.http.get<{ movements: MovementRecord[], total: number }>(\n        `/api/inventory/products/${this.productId()}/movements`,\n        { params }\n      )\n    );\n\n    this.internalMovements.set(response.movements);\n    this.onMovementsLoad.emit(response.movements);\n  } catch (error: any) {\n    console.error('Failed to load movements:', error);\n  } finally {\n    this.isLoading.set(false);\n  }\n}\n\nprivate subscribeToUpdates() {\n  this.ws.connect(`/ws/inventory/movements`);\n  this.ws.send({ type: 'subscribe', productId: this.productId() });\n\n  this.ws.messages$.subscribe((message: any) => {\n    if (message.type === 'movement' && message.data) {\n      const newMovement = message.data as MovementRecord;\n      this.internalMovements.update(movements => [newMovement, ...movements]);\n    }\n  });\n}\n```\n\n#### Export Functionality\n```typescript\nasync exportData(format: 'pdf' | 'excel') {\n  const data = this.filteredMovements();\n  this.onExport.emit({ format, data });\n\n  if (format === 'excel') {\n    await this.exportToExcel(data);\n  } else {\n    await this.exportToPdf(data);\n  }\n}\n\nprivate async exportToExcel(data: MovementRecord[]) {\n  const XLSX = await import('xlsx');\n  const worksheet = XLSX.utils.json_to_sheet(\n    data.map(m => ({\n      'Date/Time': m.timestamp.toLocaleString(),\n      'Type': m.type,\n      'Quantity': this.getQuantityChange(m),\n      'Balance': m.balanceAfter,\n      'User': m.user.name,\n      'Document': m.referenceDocument?.number || '',\n      'Batch': m.batchNumber || '',\n      'Notes': m.notes || ''\n    }))\n  );\n\n  const workbook = XLSX.utils.book_new();\n  XLSX.utils.book_append_sheet(workbook, worksheet, 'Movements');\n  XLSX.writeFile(workbook, `movements-${this.productId()}-${Date.now()}.xlsx`);\n}\n\nprivate async exportToPdf(data: MovementRecord[]) {\n  const { jsPDF } = await import('jspdf');\n  const doc = new jsPDF();\n\n  doc.setFontSize(16);\n  doc.text('Stock Movement History', 14, 20);\n  doc.setFontSize(10);\n  doc.text(`Product ID: ${this.productId()}`, 14, 30);\n\n  let y = 40;\n  data.forEach((m, i) => {\n    if (y > 270) {\n      doc.addPage();\n      y = 20;\n    }\n\n    doc.text(`${m.timestamp.toLocaleString()} | ${m.type} | ${this.getQuantityChange(m)} â†’ ${m.balanceAfter}`, 14, y);\n    y += 7;\n  });\n\n  doc.save(`movements-${this.productId()}-${Date.now()}.pdf`);\n}\n```\n\n---\n\n## 2. Expiry Date Badge (`ax-expiry-badge`)\n\n### 2.1 Visual Design\n\n#### Layout Variants\n```\nSmall:     [ğŸŸ¢ Safe]\nMedium:    [ğŸŸ¡ 15 days left]\nLarge:     [ğŸ”´ Critical - 3 days left]\nCompact:   ğŸ”´ (tooltip on hover)\n```\n\n#### Color Scheme\n- **Safe**: `bg-success-100 text-success-800 border-success-300`\n- **Warning**: `bg-warning-100 text-warning-800 border-warning-300`\n- **Critical**: `bg-error-100 text-error-800 border-error-300`\n- **Expired**: `bg-neutral-100 text-neutral-600 border-neutral-300`\n\n### 2.2 Component Architecture\n\n```typescript\n@Component({\n  selector: 'ax-expiry-badge',\n  standalone: true,\n  imports: [CommonModule, MatTooltipModule, MatIconModule, AxBadgeComponent],\n  template: `\n    <ax-badge\n      [type]=\"badgeType()\"\n      [size]=\"size()\"\n      [variant]=\"variant()\"\n      [content]=\"badgeText()\"\n      [matTooltip]=\"tooltipText()\"\n      (click)=\"handleClick()\"\n      [class.ax-expiry-badge--compact]=\"compact()\">\n      @if (showIcon() && !compact()) {\n        <mat-icon [class]=\"'ax-expiry-badge__icon--' + expiryStatus()\">\n          {{ statusIcon() }}\n        </mat-icon>\n      }\n    </ax-badge>\n  `,\n  styles: [`\n    .ax-expiry-badge--compact {\n      min-width: 24px;\n      padding: 4px;\n    }\n  `]\n})\nexport class AxExpiryBadgeComponent {\n  // Inputs\n  expiryDate = input.required<Date>();\n  warningDays = input<number>(30);\n  criticalDays = input<number>(7);\n  showCountdown = input<boolean>(true);\n  showIcon = input<boolean>(true);\n  size = input<'sm' | 'md' | 'lg'>('md');\n  variant = input<'outlined' | 'soft' | 'solid'>('soft');\n  compact = input<boolean>(false);\n\n  // Output\n  onClick = output<ExpiryInfo>();\n\n  // Computed\n  expiryStatus = computed((): ExpiryStatus => {\n    const days = this.daysUntilExpiry();\n    if (days < 0) return 'expired';\n    if (days <= this.criticalDays()) return 'critical';\n    if (days <= this.warningDays()) return 'warning';\n    return 'safe';\n  });\n\n  daysUntilExpiry = computed(() => {\n    const now = new Date();\n    const expiry = new Date(this.expiryDate());\n    return Math.ceil((expiry.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));\n  });\n\n  badgeType = computed((): BadgeType => {\n    const status = this.expiryStatus();\n    if (status === 'safe') return 'success';\n    if (status === 'warning') return 'warning';\n    if (status === 'critical') return 'error';\n    return 'neutral';\n  });\n\n  badgeText = computed(() => {\n    if (this.compact()) return '';\n\n    const status = this.expiryStatus();\n    const days = this.daysUntilExpiry();\n\n    if (!this.showCountdown()) {\n      return status.charAt(0).toUpperCase() + status.slice(1);\n    }\n\n    if (status === 'expired') {\n      return `EXPIRED ${Math.abs(days)} days ago`;\n    }\n    if (status === 'critical') {\n      return `${days} days left`;\n    }\n    if (status === 'warning') {\n      return `${days} days left`;\n    }\n    return `Expires in ${days} days`;\n  });\n\n  statusIcon = computed(() => {\n    const status = this.expiryStatus();\n    if (status === 'safe') return 'check_circle';\n    if (status === 'warning') return 'warning';\n    if (status === 'critical') return 'error';\n    return 'cancel';\n  });\n\n  tooltipText = computed(() => {\n    const expiry = new Date(this.expiryDate());\n    return `Expiry Date: ${expiry.toLocaleDateString()} ${expiry.toLocaleTimeString()}`;\n  });\n\n  handleClick() {\n    this.onClick.emit({\n      expiryDate: this.expiryDate(),\n      daysUntilExpiry: this.daysUntilExpiry(),\n      status: this.expiryStatus(),\n      message: this.badgeText()\n    });\n  }\n}\n```\n\n---\n\n## 3. Product Variant Selector (`ax-variant-selector`)\n\n### 3.1 Visual Design\n\n#### Grid Layout\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  Product Variants                        [Layout: Gridâ–¼]â”‚\nâ”‚  ğŸ” [Search variants...]                                â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚\nâ”‚  â”‚  ğŸ“¸   â”‚  â”‚  ğŸ“¸   â”‚  â”‚  ğŸ“¸   â”‚  â”‚  ğŸ“¸   â”‚       â”‚\nâ”‚  â”‚  Blue  â”‚  â”‚   Red  â”‚  â”‚ Green  â”‚  â”‚ Yellow â”‚       â”‚\nâ”‚  â”‚ Size M â”‚  â”‚ Size M â”‚  â”‚ Size M â”‚  â”‚ Size M â”‚       â”‚\nâ”‚  â”‚ $29.99 â”‚  â”‚ $29.99 â”‚  â”‚ $32.99 â”‚  â”‚ $29.99 â”‚       â”‚\nâ”‚  â”‚ ğŸŸ¢ 45  â”‚  â”‚ ğŸŸ¡ 8   â”‚  â”‚ ğŸŸ¢ 120 â”‚  â”‚ ğŸ”´ Out â”‚       â”‚\nâ”‚  â”‚ [âœ“]    â”‚  â”‚ [ ]    â”‚  â”‚ [ ]    â”‚  â”‚ [Ã—]    â”‚       â”‚\nâ”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n### 3.2 Component Architecture\n\n```typescript\n@Component({\n  selector: 'ax-variant-selector',\n  standalone: true,\n  imports: [\n    CommonModule,\n    FormsModule,\n    MatFormFieldModule,\n    MatInputModule,\n    MatSelectModule,\n    MatCheckboxModule,\n    MatRadioModule,\n    MatIconModule\n  ]\n})\nexport class AxVariantSelectorComponent {\n  // Inputs\n  productId = input.required<string>();\n  variants = input.required<ProductVariant[]>();\n  attributes = input<string[]>([]);\n  layout = input<'grid' | 'list' | 'dropdown'>('grid');\n  showImages = input<boolean>(true);\n  showStock = input<boolean>(true);\n  showPrice = input<boolean>(true);\n  allowMultiple = input<boolean>(false);\n  lowStockThreshold = input<number>(10);\n\n  // Outputs\n  onVariantSelect = output<VariantSelection>();\n  onAttributeFilter = output<{ attribute: string, value: string }>();\n\n  // Internal state\n  private selectedVariants = signal<Map<string, number>>(new Map());\n  private searchTerm = signal<string>('');\n  private attributeFilters = signal<Map<string, string>>(new Map());\n\n  // Computed\n  filteredVariants = computed(() => {\n    let variants = this.variants();\n    const search = this.searchTerm().toLowerCase();\n    const filters = this.attributeFilters();\n\n    if (search) {\n      variants = variants.filter(v =>\n        v.name.toLowerCase().includes(search) ||\n        v.sku.toLowerCase().includes(search) ||\n        Object.values(v.attributes).some(val =>\n          String(val).toLowerCase().includes(search)\n        )\n      );\n    }\n\n    if (filters.size > 0) {\n      variants = variants.filter(v =>\n        Array.from(filters.entries()).every(([attr, value]) =>\n          v.attributes[attr] === value\n        )\n      );\n    }\n\n    return variants;\n  });\n\n  availableAttributes = computed(() => {\n    const attrs = this.attributes();\n    if (attrs.length > 0) return attrs;\n\n    const variants = this.variants();\n    const allAttrs = new Set<string>();\n    variants.forEach(v => {\n      Object.keys(v.attributes).forEach(attr => allAttrs.add(attr));\n    });\n    return Array.from(allAttrs);\n  });\n\n  getStockBadgeType(variant: ProductVariant): 'success' | 'warning' | 'error' {\n    if (!variant.available) return 'error';\n    if (variant.stockLevel <= this.lowStockThreshold()) return 'warning';\n    return 'success';\n  }\n\n  toggleVariant(variant: ProductVariant) {\n    if (!variant.available) return;\n\n    const selected = this.selectedVariants();\n\n    if (this.allowMultiple()) {\n      if (selected.has(variant.sku)) {\n        selected.delete(variant.sku);\n      } else {\n        selected.set(variant.sku, 1);\n      }\n    } else {\n      selected.clear();\n      selected.set(variant.sku, 1);\n    }\n\n    this.selectedVariants.set(new Map(selected));\n    this.emitSelection();\n  }\n\n  updateQuantity(sku: string, quantity: number) {\n    this.selectedVariants().set(sku, quantity);\n    this.emitSelection();\n  }\n\n  private emitSelection() {\n    const selection: VariantSelection = {\n      variants: Array.from(this.selectedVariants().entries()).map(([sku, quantity]) => ({\n        variant: this.variants().find(v => v.sku === sku)!,\n        quantity\n      }))\n    };\n    this.onVariantSelect.emit(selection);\n  }\n}\n```\n\n---\n\n## 4. Stock Alert Panel (`ax-stock-alert-panel`)\n\n### 4.1 Visual Design\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  Stock Alerts                         [Group: Priorityâ–¼]â”‚\nâ”‚  [Critical: 3] [Warning: 8] [Info: 2]                   â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  ğŸ”´ CRITICAL                                            â”‚\nâ”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  â”‚ ğŸ”´ Out of Stock                                     â”‚\nâ”‚  â”‚ Aspirin 500mg (SKU-001)                             â”‚\nâ”‚  â”‚ Current: 0 | Minimum: 50                            â”‚\nâ”‚  â”‚ [Create PO] [View Product]                          â”‚\nâ”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  â”‚ ğŸ”´ Expired Product                                  â”‚\nâ”‚  â”‚ Ibuprofen 200mg (SKU-042)                           â”‚\nâ”‚  â”‚ Batch: BATCH-2023-099 | Expired: 5 days ago        â”‚\nâ”‚  â”‚ [Dispose] [View Product]                            â”‚\nâ”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\nâ”‚                                                         â”‚\nâ”‚  ğŸŸ¡ WARNING                                             â”‚\nâ”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  â”‚ ğŸŸ¡ Low Stock                                        â”‚\nâ”‚  â”‚ Paracetamol 650mg (SKU-015)                         â”‚\nâ”‚  â”‚ Current: 25 | Minimum: 50                           â”‚\nâ”‚  â”‚ [Reorder] [View Product]                            â”‚\nâ”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\nâ”‚                                                         â”‚\nâ”‚  [View All Alerts (13)]                                 â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n### 4.2 Component Architecture\n\n```typescript\n@Component({\n  selector: 'ax-stock-alert-panel',\n  standalone: true,\n  imports: [\n    CommonModule,\n    MatButtonModule,\n    MatIconModule,\n    MatBadgeModule,\n    AxBadgeComponent\n  ]\n})\nexport class AxStockAlertPanelComponent implements OnInit {\n  private readonly http = inject(HttpClient);\n  private readonly ws = inject(WebSocketService);\n\n  // Inputs\n  alerts = input<StockAlert[]>([]);\n  groupBy = input<'type' | 'priority' | 'none'>('priority');\n  showActions = input<boolean>(true);\n  maxDisplay = input<number>(10);\n  enableRealtime = input<boolean>(false);\n  filters = input<AlertFilter | undefined>(undefined);\n\n  // Outputs\n  onAlertClick = output<StockAlert>();\n  onAlertAction = output<{ alert: StockAlert, action: string }>();\n  onAlertDismiss = output<string>();\n  onAlertsLoad = output<StockAlert[]>();\n\n  // Internal state\n  private internalAlerts = signal<StockAlert[]>([]);\n  private isLoading = signal<boolean>(false);\n\n  // Computed\n  filteredAlerts = computed(() => {\n    let alerts = this.internalAlerts();\n    const filter = this.filters();\n\n    if (filter?.types) {\n      alerts = alerts.filter(a => filter.types!.includes(a.type));\n    }\n    if (filter?.severity) {\n      alerts = alerts.filter(a => filter.severity!.includes(a.severity));\n    }\n    if (filter?.productIds) {\n      alerts = alerts.filter(a => filter.productIds!.includes(a.product.id));\n    }\n\n    return alerts;\n  });\n\n  groupedAlerts = computed(() => {\n    const alerts = this.filteredAlerts();\n    const grouping = this.groupBy();\n\n    if (grouping === 'none') {\n      return [{ key: 'all', label: 'All Alerts', alerts }];\n    }\n\n    const groups = new Map<string, StockAlert[]>();\n\n    alerts.forEach(alert => {\n      const key = grouping === 'type' ? alert.type : alert.severity;\n      if (!groups.has(key)) {\n        groups.set(key, []);\n      }\n      groups.get(key)!.push(alert);\n    });\n\n    return Array.from(groups.entries()).map(([key, alerts]) => ({\n      key,\n      label: this.getGroupLabel(key, grouping),\n      alerts: alerts.slice(0, this.maxDisplay())\n    }));\n  });\n\n  alertCounts = computed(() => {\n    const alerts = this.filteredAlerts();\n    return {\n      critical: alerts.filter(a => a.severity === 'critical').length,\n      warning: alerts.filter(a => a.severity === 'warning').length,\n      info: alerts.filter(a => a.severity === 'info').length\n    };\n  });\n\n  async ngOnInit() {\n    if (!this.alerts().length) {\n      await this.loadAlerts();\n    } else {\n      this.internalAlerts.set(this.alerts());\n    }\n\n    if (this.enableRealtime()) {\n      this.subscribeToAlerts();\n    }\n  }\n\n  private async loadAlerts() {\n    this.isLoading.set(true);\n\n    try {\n      const params: any = {};\n      const filter = this.filters();\n\n      if (filter?.types) params.types = filter.types;\n      if (filter?.severity) params.severity = filter.severity;\n\n      const response = await firstValueFrom(\n        this.http.get<{ alerts: StockAlert[], total: number }>(\n          '/api/inventory/alerts',\n          { params }\n        )\n      );\n\n      this.internalAlerts.set(response.alerts);\n      this.onAlertsLoad.emit(response.alerts);\n    } catch (error) {\n      console.error('Failed to load alerts:', error);\n    } finally {\n      this.isLoading.set(false);\n    }\n  }\n\n  private subscribeToAlerts() {\n    this.ws.connect('/ws/inventory/alerts');\n\n    this.ws.messages$.subscribe((message: any) => {\n      if (message.type === 'alert' && message.data) {\n        const newAlert = message.data as StockAlert;\n        this.internalAlerts.update(alerts => [newAlert, ...alerts]);\n      }\n    });\n  }\n\n  async dismissAlert(alertId: string) {\n    try {\n      await firstValueFrom(\n        this.http.post(`/api/inventory/alerts/${alertId}/dismiss`, {})\n      );\n\n      this.internalAlerts.update(alerts =>\n        alerts.filter(a => a.id !== alertId)\n      );\n\n      this.onAlertDismiss.emit(alertId);\n    } catch (error) {\n      console.error('Failed to dismiss alert:', error);\n    }\n  }\n\n  handleAction(alert: StockAlert, action: string) {\n    this.onAlertAction.emit({ alert, action });\n  }\n}\n```\n\n---\n\n## 5. Inventory Transfer Wizard (`ax-transfer-wizard`)\n\n### 5.3 Component Architecture\n\n```typescript\n@Component({\n  selector: 'ax-transfer-wizard',\n  standalone: true,\n  imports: [\n    CommonModule,\n    ReactiveFormsModule,\n    MatStepperModule,\n    MatFormFieldModule,\n    MatInputModule,\n    MatButtonModule,\n    MatTableModule,\n    AxQuantityInputComponent,\n    AxLocationPickerComponent\n  ]\n})\nexport class AxTransferWizardComponent {\n  private readonly fb = inject(FormBuilder);\n\n  // Inputs\n  sourceLocation = input.required<string>();\n  steps = input<WizardStep[]>([]);\n  allowPartialTransfer = input<boolean>(true);\n  requireApproval = input<boolean>(false);\n  allowMultipleProducts = input<boolean>(true);\n\n  // Outputs\n  onComplete = output<TransferRequest>();\n  onCancel = output<void>();\n  onStepChange = output<{ step: number, data: any }>();\n\n  // Form\n  transferForm = this.fb.group({\n    products: this.fb.array([]),\n    destinationLocation: ['', Validators.required],\n    notes: ['']\n  });\n\n  currentStep = signal<number>(0);\n  selectedProducts = signal<Array<{ id: string, name: string, available: number }>>([]);\n\n  get productsArray() {\n    return this.transferForm.get('products') as FormArray;\n  }\n\n  addProduct(product: { id: string, name: string, available: number }) {\n    const productGroup = this.fb.group({\n      productId: [product.id],\n      productName: [product.name],\n      availableQuantity: [product.available],\n      quantity: [0, [Validators.required, Validators.min(1), Validators.max(product.available)]]\n    });\n\n    this.productsArray.push(productGroup);\n    this.selectedProducts.update(products => [...products, product]);\n  }\n\n  removeProduct(index: number) {\n    this.productsArray.removeAt(index);\n    this.selectedProducts.update(products => products.filter((_, i) => i !== index));\n  }\n\n  nextStep() {\n    if (this.validateCurrentStep()) {\n      this.currentStep.update(step => step + 1);\n      this.onStepChange.emit({ step: this.currentStep(), data: this.getStepData() });\n    }\n  }\n\n  previousStep() {\n    this.currentStep.update(step => Math.max(0, step - 1));\n  }\n\n  async submit() {\n    if (!this.transferForm.valid) return;\n\n    const formValue = this.transferForm.value;\n    const request: TransferRequest = {\n      sourceLocationId: this.sourceLocation(),\n      destinationLocationId: formValue.destinationLocation!,\n      items: formValue.products!.map((p: any) => ({\n        productId: p.productId,\n        quantity: p.quantity\n      })),\n      notes: formValue.notes || undefined,\n      requiresApproval: this.requireApproval()\n    };\n\n    this.onComplete.emit(request);\n  }\n\n  cancel() {\n    this.onCancel.emit();\n  }\n\n  private validateCurrentStep(): boolean {\n    const step = this.currentStep();\n\n    switch (step) {\n      case 0: // Select Products\n        return this.productsArray.length > 0;\n      case 1: // Confirm Quantities\n        return this.productsArray.controls.every(c => c.valid);\n      case 2: // Select Destination\n        return this.transferForm.get('destinationLocation')!.valid;\n      default:\n        return true;\n    }\n  }\n\n  private getStepData(): any {\n    const step = this.currentStep();\n\n    switch (step) {\n      case 0:\n        return { products: this.selectedProducts() };\n      case 1:\n        return { quantities: this.productsArray.value };\n      case 2:\n        return { destination: this.transferForm.get('destinationLocation')!.value };\n      default:\n        return null;\n    }\n  }\n}\n```\n\n---\n\n## 6. Location/Warehouse Picker (`ax-location-picker`)\n\n### 6.1 Component Architecture\n\n```typescript\n@Component({\n  selector: 'ax-location-picker',\n  standalone: true,\n  imports: [\n    CommonModule,\n    FormsModule,\n    MatTreeModule,\n    MatIconModule,\n    MatFormFieldModule,\n    MatInputModule,\n    MatSelectModule,\n    MatButtonModule\n  ]\n})\nexport class AxLocationPickerComponent implements OnInit {\n  private readonly http = inject(HttpClient);\n\n  // Inputs\n  locations = input.required<LocationNode[]>();\n  currentLocation = input<string | undefined>(undefined);\n  showAvailability = input<boolean>(false);\n  allowedTypes = input<LocationType[]>([]);\n  showRecent = input<boolean>(true);\n  showFavorites = input<boolean>(true);\n  showMap = input<boolean>(false);\n  searchable = input<boolean>(true);\n  mode = input<'tree' | 'dropdown' | 'breadcrumb'>('tree');\n\n  // Outputs\n  onLocationSelect = output<LocationSelection>();\n  onFavoriteToggle = output<{ locationId: string, isFavorite: boolean }>();\n\n  // Internal state\n  private searchTerm = signal<string>('');\n  private expandedNodes = signal<Set<string>>(new Set());\n  private recentLocations = signal<LocationNode[]>([]);\n  private favoriteLocations = signal<LocationNode[]>([]);\n\n  // Tree data source\n  dataSource = new MatTreeFlatDataSource(this.treeControl, this.treeFlattener);\n  treeControl = new FlatTreeControl<FlatLocationNode>(\n    node => node.level,\n    node => node.expandable\n  );\n\n  treeFlattener = new MatTreeFlattener(\n    (node: LocationNode, level: number): FlatLocationNode => ({\n      ...node,\n      level,\n      expandable: !!node.children && node.children.length > 0\n    }),\n    node => node.level,\n    node => node.expandable,\n    node => node.children || []\n  );\n\n  ngOnInit() {\n    this.dataSource.data = this.locations();\n    this.loadRecentLocations();\n    this.loadFavoriteLocations();\n\n    if (this.currentLocation()) {\n      this.expandToLocation(this.currentLocation()!);\n    }\n  }\n\n  // Computed\n  filteredLocations = computed(() => {\n    const locations = this.locations();\n    const search = this.searchTerm().toLowerCase();\n\n    if (!search) return locations;\n\n    return this.filterTree(locations, search);\n  });\n\n  private filterTree(nodes: LocationNode[], search: string): LocationNode[] {\n    return nodes.reduce<LocationNode[]>((acc, node) => {\n      const matches = node.code.toLowerCase().includes(search) ||\n                     node.name.toLowerCase().includes(search);\n\n      const filteredChildren = node.children ? this.filterTree(node.children, search) : [];\n\n      if (matches || filteredChildren.length > 0) {\n        acc.push({\n          ...node,\n          children: filteredChildren.length > 0 ? filteredChildren : node.children\n        });\n      }\n\n      return acc;\n    }, []);\n  }\n\n  selectLocation(location: LocationNode) {\n    const allowed = this.allowedTypes();\n    if (allowed.length > 0 && !allowed.includes(location.type)) {\n      return;\n    }\n\n    if (location.disabled) {\n      return;\n    }\n\n    const path = this.getLocationPath(location);\n    const selection: LocationSelection = {\n      location,\n      path,\n      pathString: path.map(l => l.code).join(' > ')\n    };\n\n    this.onLocationSelect.emit(selection);\n    this.addToRecent(location);\n  }\n\n  toggleFavorite(location: LocationNode) {\n    const favorites = this.favoriteLocations();\n    const isFavorite = favorites.some(f => f.id === location.id);\n\n    if (isFavorite) {\n      this.favoriteLocations.set(favorites.filter(f => f.id !== location.id));\n    } else {\n      this.favoriteLocations.set([...favorites, location]);\n    }\n\n    this.saveFavorites();\n    this.onFavoriteToggle.emit({ locationId: location.id, isFavorite: !isFavorite });\n  }\n\n  private getLocationPath(location: LocationNode): LocationNode[] {\n    const path: LocationNode[] = [location];\n    let current = location;\n\n    while (current.parentId) {\n      const parent = this.findLocationById(current.parentId);\n      if (parent) {\n        path.unshift(parent);\n        current = parent;\n      } else {\n        break;\n      }\n    }\n\n    return path;\n  }\n\n  private findLocationById(id: string): LocationNode | null {\n    const search = (nodes: LocationNode[]): LocationNode | null => {\n      for (const node of nodes) {\n        if (node.id === id) return node;\n        if (node.children) {\n          const found = search(node.children);\n          if (found) return found;\n        }\n      }\n      return null;\n    };\n\n    return search(this.locations());\n  }\n\n  private expandToLocation(locationId: string) {\n    const location = this.findLocationById(locationId);\n    if (!location) return;\n\n    const path = this.getLocationPath(location);\n    path.forEach(node => {\n      this.expandedNodes.update(nodes => {\n        nodes.add(node.id);\n        return new Set(nodes);\n      });\n    });\n  }\n\n  private addToRecent(location: LocationNode) {\n    const recent = this.recentLocations();\n    const filtered = recent.filter(l => l.id !== location.id);\n    this.recentLocations.set([location, ...filtered].slice(0, 5));\n    localStorage.setItem('recentLocations', JSON.stringify(this.recentLocations()));\n  }\n\n  private loadRecentLocations() {\n    const stored = localStorage.getItem('recentLocations');\n    if (stored) {\n      this.recentLocations.set(JSON.parse(stored));\n    }\n  }\n\n  private saveFavorites() {\n    localStorage.setItem('favoriteLocations', JSON.stringify(this.favoriteLocations()));\n  }\n\n  private loadFavoriteLocations() {\n    const stored = localStorage.getItem('favoriteLocations');\n    if (stored) {\n      this.favoriteLocations.set(JSON.parse(stored));\n    }\n  }\n}\n```\n\n---\n\n## 7. Testing Strategy\n\n### 7.1 Unit Testing\n\nEach component will have comprehensive unit tests:\n\n```typescript\ndescribe('AxStockMovementTimelineComponent', () => {\n  it('should group movements by day', () => {\n    component.groupBy.set('day');\n    component.internalMovements.set(mockMovements);\n\n    const grouped = component.groupedMovements();\n    expect(grouped.length).toBeGreaterThan(0);\n    expect(grouped[0].key).toMatch(/\\d{4}-\\d{2}-\\d{2}/);\n  });\n\n  it('should calculate net change correctly', () => {\n    const movements: MovementRecord[] = [\n      { type: 'receive', quantity: 100, ... },\n      { type: 'issue', quantity: 50, ... }\n    ];\n\n    const net = component.calculateNetChange(movements);\n    expect(net).toBe(50);\n  });\n});\n```\n\n### 7.2 Integration Testing\n\nTest cross-component interactions:\n\n```typescript\ndescribe('Transfer Wizard with Location Picker', () => {\n  it('should complete transfer flow', async () => {\n    // Step 1: Select products\n    wizard.addProduct(mockProduct);\n\n    // Step 2: Set quantities\n    wizard.productsArray.at(0).patchValue({ quantity: 100 });\n    wizard.nextStep();\n\n    // Step 3: Select destination using location picker\n    const locationPicker = fixture.debugElement.query(By.directive(AxLocationPickerComponent));\n    locationPicker.componentInstance.selectLocation(mockLocation);\n\n    // Step 4: Submit\n    wizard.submit();\n\n    expect(wizard.onComplete).toHaveBeenCalled();\n  });\n});\n```\n\n### 7.3 E2E Testing\n\n```typescript\ntest('Stock alert panel flow', async ({ page }) => {\n  await page.goto('/dashboard');\n\n  // Verify alert count\n  const criticalCount = await page.textContent('[data-testid=\"critical-count\"]');\n  expect(criticalCount).toBe('3');\n\n  // Click alert\n  await page.click('[data-testid=\"alert-0\"]');\n\n  // Verify navigation to product\n  await expect(page).toHaveURL(/\\/products\\/*/);\n});\n```\n\n---\n\n## 8. Performance Optimization\n\n### 8.1 Virtual Scrolling for Timeline\n\n```typescript\n<cdk-virtual-scroll-viewport itemSize=\"80\" class=\"timeline-viewport\">\n  @for (group of groupedMovements(); track group.key) {\n    <div class=\"date-group\">\n      <h3>{{ group.date | date }}</h3>\n      @for (movement of group.movements; track movement.id) {\n        <div class=\"movement-card\">...</div>\n      }\n    </div>\n  }\n</cdk-virtual-scroll-viewport>\n```\n\n### 8.2 Lazy Loading\n\n```typescript\n// Lazy load Chart.js\nconst loadChart = async () => {\n  const { Chart } = await import('chart.js');\n  return Chart;\n};\n\n// Lazy load export libraries\nconst loadExportLib = async (format: 'pdf' | 'excel') => {\n  if (format === 'pdf') {\n    return await import('jspdf');\n  } else {\n    return await import('xlsx');\n  }\n};\n```\n\n---\n\n## 9. Implementation Roadmap\n\n### Phase 1: Foundation (Week 1)\n- Set up component directories\n- Install dependencies (Chart.js, jsPDF, xlsx)\n- Create shared types\n\n### Phase 2: Simple Components (Week 2)\n- Expiry Badge (2 days)\n- Variant Selector (3 days)\n\n### Phase 3: Complex Components (Week 3-4)\n- Stock Movement Timeline (4 days)\n- Stock Alert Panel (3 days)\n\n### Phase 4: Wizard & Picker (Week 5)\n- Transfer Wizard (3 days)\n- Location Picker (4 days)\n\n### Phase 5: Integration & Testing (Week 6)\n- Cross-component integration\n- E2E tests\n- Performance optimization\n- Documentation\n\n---\n\n*Design Version: 1.0*\n*Last Updated: 2025-12-18*\n*Status: Awaiting Approval*\n",
  "fileStats": {
    "size": 42392,
    "lines": 1386,
    "lastModified": "2025-12-18T23:40:05.064Z"
  },
  "comments": []
}
