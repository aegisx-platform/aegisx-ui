{
  "id": "snapshot_1766076787556_u0orx7ncw",
  "approvalId": "approval_1766076787511_cty0rh3u7",
  "approvalTitle": "Tasks Document - Inventory UI Components (Priority 1)",
  "version": 1,
  "timestamp": "2025-12-18T16:53:07.556Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Tasks - Inventory UI Components (Priority 1)\n\n## Overview\n\nThis document breaks down the implementation of 4 Priority 1 inventory components into actionable tasks. Tasks are organized by phase and component, with clear acceptance criteria and dependencies.\n\n**Status Legend:**\n- `[ ]` Pending\n- `[-]` In Progress\n- `[x]` Completed\n\n---\n\n## Phase 1: Foundation & Setup\n\n### 1.1 Project Structure Setup\n\n**[ ] Task 1.1.1: Create component directories**\n\nCreate directory structure for inventory components:\n\n```\nlibs/aegisx-ui/src/lib/components/inventory/\n├── stock-level/\n│   ├── stock-level.component.ts\n│   ├── stock-level.component.scss\n│   ├── stock-level.component.spec.ts\n│   ├── stock-level.types.ts\n│   └── index.ts\n├── barcode-scanner/\n│   ├── barcode-scanner.component.ts\n│   ├── barcode-scanner.component.scss\n│   ├── barcode-scanner.component.spec.ts\n│   ├── barcode-scanner.types.ts\n│   └── index.ts\n├── quantity-input/\n│   ├── quantity-input.component.ts\n│   ├── quantity-input.component.scss\n│   ├── quantity-input.component.spec.ts\n│   ├── quantity-input.types.ts\n│   └── index.ts\n└── batch-selector/\n    ├── batch-selector.component.ts\n    ├── batch-selector.component.scss\n    ├── batch-selector.component.spec.ts\n    ├── batch-selector.types.ts\n    └── index.ts\n```\n\n**Acceptance Criteria:**\n- All directories created under `libs/aegisx-ui/src/lib/components/inventory/`\n- Each component has 5 required files: component.ts, .scss, .spec.ts, .types.ts, index.ts\n- index.ts files export all public APIs\n\n**Dependencies:** None\n\n---\n\n**[ ] Task 1.1.2: Install required dependencies**\n\nInstall external libraries needed for barcode scanning:\n\n```bash\npnpm add @zxing/library\npnpm add -D @types/dom-mediacapture-record\n```\n\n**Acceptance Criteria:**\n- `@zxing/library` installed in package.json\n- `@types/dom-mediacapture-record` installed as devDependency\n- `pnpm install` completes without errors\n- No TypeScript errors from missing type definitions\n\n**Dependencies:** None\n\n---\n\n**[ ] Task 1.1.3: Create shared inventory types**\n\nCreate `libs/aegisx-ui/src/lib/types/inventory.types.ts` with common types:\n\n```typescript\n/**\n * Common unit configuration for quantity inputs\n */\nexport interface UnitConfig {\n  /** Unit code (e.g., 'piece', 'box', 'kg') */\n  code: string;\n  /** Display label */\n  label: string;\n  /** Conversion rate to base unit */\n  conversionRate: number;\n  /** Allowed decimal places */\n  decimalPlaces: number;\n  /** Optional unit symbol */\n  symbol?: string;\n}\n\n/**\n * Batch/Lot information\n */\nexport interface BatchInfo {\n  batchNumber: string;\n  lotNumber?: string;\n  expiryDate: Date;\n  manufacturingDate?: Date;\n  availableQuantity: number;\n  unit: string;\n  location?: string;\n  status: 'available' | 'reserved' | 'expired' | 'quarantine';\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Inventory strategy for batch selection\n */\nexport type InventoryStrategy = 'fifo' | 'fefo' | 'lifo';\n```\n\n**Acceptance Criteria:**\n- File created at `libs/aegisx-ui/src/lib/types/inventory.types.ts`\n- All interfaces have complete JSDoc comments\n- Types exported from `libs/aegisx-ui/src/index.ts`\n- No TypeScript errors\n\n**Dependencies:** None\n\n---\n\n**[ ] Task 1.1.4: Update public API exports**\n\nUpdate `libs/aegisx-ui/src/index.ts` to export inventory components:\n\n```typescript\n// Inventory Components\nexport * from './lib/components/inventory/stock-level';\nexport * from './lib/components/inventory/barcode-scanner';\nexport * from './lib/components/inventory/quantity-input';\nexport * from './lib/components/inventory/batch-selector';\n\n// Inventory Types\nexport * from './lib/types/inventory.types';\n```\n\n**Acceptance Criteria:**\n- All inventory components exported from main index.ts\n- No circular dependencies\n- Build succeeds with `pnpm nx build aegisx-ui`\n\n**Dependencies:** 1.1.1, 1.1.3\n\n---\n\n## Phase 2: Stock Level Indicator Component\n\n### 2.1 Types & Interfaces\n\n**[ ] Task 2.1.1: Create stock-level.types.ts**\n\nCreate type definitions:\n\n```typescript\n/**\n * Stock level component size\n */\nexport type StockLevelSize = 'sm' | 'md' | 'lg';\n\n/**\n * Color scheme for stock level display\n */\nexport type StockLevelColorScheme = 'traffic-light' | 'gradient';\n\n/**\n * Stock level warning event\n */\nexport interface StockLevelWarningEvent {\n  /** Warning level triggered */\n  level: 'low' | 'critical';\n  /** Current stock value */\n  current: number;\n  /** Minimum threshold */\n  minimum: number;\n}\n```\n\n**Acceptance Criteria:**\n- All types have JSDoc comments\n- Types exported from component index.ts\n- No TypeScript errors\n\n**Dependencies:** 1.1.1\n\n---\n\n### 2.2 Component Implementation\n\n**[ ] Task 2.2.1: Implement stock-level component scaffold**\n\nCreate basic component structure with inputs and outputs:\n\n```typescript\n@Component({\n  selector: 'ax-stock-level',\n  standalone: true,\n  imports: [CommonModule, MatTooltipModule, AxBadgeComponent],\n  templateUrl: './stock-level.component.html',\n  styleUrls: ['./stock-level.component.scss']\n})\nexport class AxStockLevelComponent {\n  // Inputs\n  current = input.required<number>();\n  minimum = input.required<number>();\n  maximum = input.required<number>();\n  unit = input<string>('pieces');\n  size = input<StockLevelSize>('md');\n  showLabel = input<boolean>(true);\n  showPercentage = input<boolean>(true);\n  colorScheme = input<StockLevelColorScheme>('traffic-light');\n\n  // Output\n  onWarningClick = output<StockLevelWarningEvent>();\n}\n```\n\n**Acceptance Criteria:**\n- Component compiles without errors\n- All required inputs defined with `input.required()`\n- Optional inputs have default values\n- Output defined with `output<T>()`\n\n**Dependencies:** 2.1.1\n\n---\n\n**[ ] Task 2.2.2: Implement computed signals for stock level**\n\nAdd computed properties:\n\n```typescript\n// Computed percentage\npercentage = computed(() => {\n  const max = this.maximum();\n  const curr = this.current();\n  return max > 0 ? Math.round((curr / max) * 100) : 0;\n});\n\n// Computed color class\ncolorClass = computed(() => {\n  const pct = this.percentage();\n  if (this.colorScheme() === 'traffic-light') {\n    if (pct >= 75) return 'bg-success-500';\n    if (pct >= 25) return 'bg-warning-500';\n    return 'bg-error-500';\n  } else {\n    return 'bg-gradient-to-r from-error-500 via-warning-500 to-success-500';\n  }\n});\n\n// Warning state\nisWarning = computed(() => this.current() <= this.minimum());\n\n// Tooltip text\ntooltipText = computed(() => {\n  const curr = this.current();\n  const min = this.minimum();\n  const max = this.maximum();\n  const unit = this.unit();\n  return `Current: ${curr} ${unit}\\nMinimum: ${min} ${unit}\\nMaximum: ${max} ${unit}`;\n});\n```\n\n**Acceptance Criteria:**\n- All computed signals return correct values\n- Percentage calculation handles division by zero\n- Color class matches design specifications\n- Warning triggers when current <= minimum\n\n**Dependencies:** 2.2.1\n\n---\n\n**[ ] Task 2.2.3: Create stock-level template**\n\nImplement HTML template:\n\n```html\n<div class=\"ax-stock-level\" [class]=\"'ax-stock-level--' + size()\">\n  @if (showLabel()) {\n    <div class=\"ax-stock-level__label\">\n      <span class=\"ax-stock-level__value\">\n        {{ current() }} / {{ maximum() }} {{ unit() }}\n      </span>\n      @if (showPercentage()) {\n        <span class=\"ax-stock-level__percentage\">({{ percentage() }}%)</span>\n      }\n    </div>\n  }\n\n  <div class=\"ax-stock-level__progress\"\n       [matTooltip]=\"tooltipText()\"\n       role=\"progressbar\"\n       [attr.aria-valuenow]=\"current()\"\n       [attr.aria-valuemin]=\"0\"\n       [attr.aria-valuemax]=\"maximum()\"\n       [attr.aria-label]=\"'Stock level: ' + percentage() + '%'\">\n    <div class=\"ax-stock-level__progress-bg\"></div>\n    <div class=\"ax-stock-level__progress-fill\"\n         [class]=\"colorClass()\"\n         [style.width.%]=\"percentage()\"></div>\n    <div class=\"ax-stock-level__threshold\"\n         [style.left.%]=\"(minimum() / maximum()) * 100\">\n      <span class=\"ax-stock-level__threshold-label\">min</span>\n    </div>\n  </div>\n\n  @if (isWarning()) {\n    <ax-badge type=\"warning\"\n              size=\"sm\"\n              content=\"Low Stock\"\n              (click)=\"handleWarningClick()\" />\n  }\n</div>\n```\n\n**Acceptance Criteria:**\n- Template compiles without errors\n- All control flow (@if) conditions work correctly\n- ARIA attributes present for accessibility\n- Tooltip displays on hover\n- Warning badge appears when isWarning() is true\n\n**Dependencies:** 2.2.2\n\n---\n\n**[ ] Task 2.2.4: Implement stock-level styles**\n\nCreate SCSS styles following design specifications:\n\n```scss\n.ax-stock-level {\n  display: flex;\n  flex-direction: column;\n  gap: 0.5rem;\n\n  &__label {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n  }\n\n  &__value {\n    font-size: var(--font-size-base);\n    font-weight: 600;\n    color: var(--text-primary);\n  }\n\n  &__percentage {\n    font-size: var(--font-size-xs);\n    color: var(--text-subtle);\n  }\n\n  &__progress {\n    position: relative;\n    height: 12px;\n    border-radius: 9999px;\n    overflow: hidden;\n    transition: height 0.2s ease;\n\n    &-bg {\n      position: absolute;\n      inset: 0;\n      background: var(--background-subtle);\n    }\n\n    &-fill {\n      position: absolute;\n      inset: 0;\n      transition: width 0.3s ease, background-color 0.3s ease;\n    }\n  }\n\n  &__threshold {\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    width: 2px;\n    background: var(--border-emphasis);\n    pointer-events: none;\n\n    &-label {\n      position: absolute;\n      top: -1.5rem;\n      left: 50%;\n      transform: translateX(-50%);\n      font-size: 0.625rem;\n      color: var(--text-subtle);\n    }\n  }\n\n  &--sm {\n    .ax-stock-level__progress {\n      height: 8px;\n    }\n  }\n\n  &--lg {\n    .ax-stock-level__progress {\n      height: 16px;\n    }\n  }\n\n  @media (prefers-reduced-motion: reduce) {\n    .ax-stock-level__progress-fill {\n      transition: none;\n    }\n  }\n}\n```\n\n**Acceptance Criteria:**\n- Styles match design document\n- CSS variables used for theming\n- Size variants (sm/md/lg) work correctly\n- Respects prefers-reduced-motion\n- Dark mode compatible\n\n**Dependencies:** 2.2.3\n\n---\n\n### 2.3 Testing\n\n**[ ] Task 2.3.1: Write unit tests for stock-level component**\n\nCreate comprehensive unit tests:\n\n```typescript\ndescribe('AxStockLevelComponent', () => {\n  it('should create', () => {\n    expect(component).toBeTruthy();\n  });\n\n  it('should calculate percentage correctly', () => {\n    component.current.set(250);\n    component.maximum.set(500);\n    expect(component.percentage()).toBe(50);\n  });\n\n  it('should display green color when stock > 75%', () => {\n    component.current.set(400);\n    component.minimum.set(50);\n    component.maximum.set(500);\n    expect(component.colorClass()).toContain('success');\n  });\n\n  it('should display yellow color when stock 25-75%', () => {\n    component.current.set(250);\n    component.minimum.set(50);\n    component.maximum.set(500);\n    expect(component.colorClass()).toContain('warning');\n  });\n\n  it('should display red color when stock < 25%', () => {\n    component.current.set(100);\n    component.minimum.set(50);\n    component.maximum.set(500);\n    expect(component.colorClass()).toContain('error');\n  });\n\n  it('should show warning badge when stock <= minimum', () => {\n    component.current.set(40);\n    component.minimum.set(50);\n    expect(component.isWarning()).toBe(true);\n  });\n\n  it('should emit warning click event', () => {\n    const spy = jasmine.createSpy('onWarningClick');\n    component.onWarningClick.subscribe(spy);\n    component.current.set(30);\n    component.minimum.set(50);\n\n    component.handleWarningClick();\n\n    expect(spy).toHaveBeenCalledWith({\n      level: 'low',\n      current: 30,\n      minimum: 50\n    });\n  });\n\n  it('should handle zero maximum gracefully', () => {\n    component.current.set(100);\n    component.maximum.set(0);\n    expect(component.percentage()).toBe(0);\n  });\n\n  it('should generate correct tooltip text', () => {\n    component.current.set(150);\n    component.minimum.set(50);\n    component.maximum.set(500);\n    component.unit.set('pieces');\n\n    const tooltip = component.tooltipText();\n    expect(tooltip).toContain('Current: 150 pieces');\n    expect(tooltip).toContain('Minimum: 50 pieces');\n    expect(tooltip).toContain('Maximum: 500 pieces');\n  });\n});\n```\n\n**Acceptance Criteria:**\n- All tests pass\n- Code coverage ≥80%\n- Tests cover edge cases (zero values, boundary conditions)\n- Tests verify computed signals\n\n**Dependencies:** 2.2.4\n\n---\n\n**[ ] Task 2.3.2: Add stock-level to component showcase**\n\nAdd examples to Storybook or showcase app:\n\n**Acceptance Criteria:**\n- Component appears in showcase\n- Multiple examples shown (low/medium/high stock)\n- Interactive controls for testing\n\n**Dependencies:** 2.2.4\n\n---\n\n## Phase 3: Barcode Scanner Component\n\n### 3.1 Types & Interfaces\n\n**[ ] Task 3.1.1: Create barcode-scanner.types.ts**\n\n```typescript\n/**\n * Barcode format types\n */\nexport type BarcodeFormat = 'qr' | 'ean13' | 'ean8' | 'code128' | 'code39' | 'datamatrix';\n\n/**\n * Scanner mode\n */\nexport type ScannerMode = 'camera' | 'manual' | 'auto';\n\n/**\n * Scan result\n */\nexport interface ScanResult {\n  /** Scanned barcode value */\n  code: string;\n  /** Detected format */\n  format: BarcodeFormat;\n  /** Timestamp of scan */\n  timestamp: Date;\n  /** Mode used for scanning */\n  mode: 'camera' | 'manual';\n}\n\n/**\n * Scan error types\n */\nexport interface ScanError {\n  type: 'permission-denied' | 'invalid-format' | 'camera-error' | 'timeout';\n  message: string;\n}\n```\n\n**Acceptance Criteria:**\n- All types documented with JSDoc\n- Types exported from index.ts\n- No TypeScript errors\n\n**Dependencies:** 1.1.1\n\n---\n\n### 3.2 Component Implementation\n\n**[ ] Task 3.2.1: Implement barcode-scanner scaffold**\n\nCreate component with basic structure:\n\n```typescript\n@Component({\n  selector: 'ax-barcode-scanner',\n  standalone: true,\n  imports: [CommonModule, FormsModule, MatButtonModule, MatIconModule],\n  templateUrl: './barcode-scanner.component.html',\n  styleUrls: ['./barcode-scanner.component.scss']\n})\nexport class AxBarcodeScannerComponent implements OnInit, OnDestroy {\n  @ViewChild('videoElement') videoRef?: ElementRef<HTMLVideoElement>;\n\n  // Inputs\n  mode = input<ScannerMode>('auto');\n  formats = input<BarcodeFormat[]>(['qr', 'ean13', 'code128']);\n  continuousScan = input<boolean>(false);\n  beepSound = input<boolean>(true);\n  showHistory = input<boolean>(false);\n  placeholder = input<string>('Enter barcode...');\n\n  // Outputs\n  onScan = output<ScanResult>();\n  onError = output<ScanError>();\n  onModeChange = output<'camera' | 'manual'>();\n\n  // Internal state\n  private currentMode = signal<'camera' | 'manual'>('camera');\n  private isScanning = signal<boolean>(false);\n  private hasPermission = signal<boolean | null>(null);\n  private recentScans = signal<ScanResult[]>([]);\n  private currentStream = signal<MediaStream | null>(null);\n  private flashlightEnabled = signal<boolean>(false);\n}\n```\n\n**Acceptance Criteria:**\n- Component compiles without errors\n- All inputs/outputs defined\n- ViewChild for video element declared\n\n**Dependencies:** 3.1.1\n\n---\n\n**[ ] Task 3.2.2: Implement camera initialization logic**\n\nAdd camera permission and initialization:\n\n```typescript\nasync ngOnInit() {\n  const mode = this.mode();\n  if (mode === 'auto') {\n    if (this.canUseCamera()) {\n      await this.initCameraMode();\n    } else {\n      this.switchToManualMode();\n    }\n  } else if (mode === 'camera') {\n    await this.initCameraMode();\n  } else {\n    this.switchToManualMode();\n  }\n}\n\nngOnDestroy() {\n  this.cleanupCamera();\n}\n\ncanUseCamera = computed(() => {\n  return 'mediaDevices' in navigator && 'getUserMedia' in navigator.mediaDevices;\n});\n\nprivate async initCameraMode() {\n  try {\n    const stream = await navigator.mediaDevices.getUserMedia({\n      video: {\n        facingMode: 'environment',\n        width: { ideal: 1280 },\n        height: { ideal: 720 }\n      }\n    });\n    this.currentStream.set(stream);\n    this.hasPermission.set(true);\n    this.currentMode.set('camera');\n    await this.startScanning();\n  } catch (error: any) {\n    this.hasPermission.set(false);\n    this.onError.emit({\n      type: 'permission-denied',\n      message: error.message\n    });\n    this.switchToManualMode();\n  }\n}\n\nprivate cleanupCamera() {\n  const stream = this.currentStream();\n  if (stream) {\n    stream.getTracks().forEach(track => track.stop());\n    this.currentStream.set(null);\n  }\n}\n\nprivate switchToManualMode() {\n  this.currentMode.set('manual');\n  this.onModeChange.emit('manual');\n}\n```\n\n**Acceptance Criteria:**\n- Camera permission requested on init\n- Stream started successfully\n- Fallback to manual mode on permission denied\n- Camera resources cleaned up on destroy\n- No memory leaks\n\n**Dependencies:** 3.2.1\n\n---\n\n**[ ] Task 3.2.3: Integrate ZXing barcode detection**\n\nImplement barcode scanning with ZXing:\n\n```typescript\nprivate async startScanning() {\n  const { BrowserMultiFormatReader } = await import('@zxing/library');\n  const codeReader = new BrowserMultiFormatReader();\n  const videoElement = this.videoRef?.nativeElement;\n\n  if (!videoElement) {\n    this.onError.emit({\n      type: 'camera-error',\n      message: 'Video element not found'\n    });\n    return;\n  }\n\n  try {\n    this.isScanning.set(true);\n    await codeReader.decodeFromVideoDevice(\n      undefined,\n      videoElement,\n      (result, error) => {\n        if (result) {\n          this.handleScanSuccess(result);\n        }\n      }\n    );\n  } catch (error: any) {\n    this.isScanning.set(false);\n    this.onError.emit({\n      type: 'camera-error',\n      message: error.message\n    });\n  }\n}\n\nprivate handleScanSuccess(result: any) {\n  const scanResult: ScanResult = {\n    code: result.getText(),\n    format: this.mapBarcodeFormat(result.getBarcodeFormat()),\n    timestamp: new Date(),\n    mode: 'camera'\n  };\n\n  if (this.beepSound()) {\n    this.playBeep();\n  }\n\n  const scans = [scanResult, ...this.recentScans()];\n  this.recentScans.set(scans.slice(0, 10));\n\n  this.onScan.emit(scanResult);\n\n  if (!this.continuousScan()) {\n    this.isScanning.set(false);\n  }\n}\n\nprivate mapBarcodeFormat(format: any): BarcodeFormat {\n  // Map ZXing formats to our format type\n  const formatMap: Record<number, BarcodeFormat> = {\n    // Implementation based on ZXing BarcodeFormat enum\n  };\n  return formatMap[format] || 'qr';\n}\n```\n\n**Acceptance Criteria:**\n- ZXing library lazy loaded\n- Barcode detected from video stream\n- Correct format mapping\n- Scan result emitted\n- Continuous scan mode works\n\n**Dependencies:** 3.2.2, 1.1.2\n\n---\n\n**[ ] Task 3.2.4: Implement manual input mode**\n\nAdd manual barcode entry:\n\n```typescript\nmanualInput = signal<string>('');\n\nonManualSubmit() {\n  const code = this.manualInput().trim();\n\n  if (!code) return;\n\n  if (!this.validateManualInput(code)) {\n    return;\n  }\n\n  const result: ScanResult = {\n    code,\n    format: this.detectFormat(code) || 'qr',\n    timestamp: new Date(),\n    mode: 'manual'\n  };\n\n  if (this.beepSound()) {\n    this.playBeep();\n  }\n\n  const scans = [result, ...this.recentScans()];\n  this.recentScans.set(scans.slice(0, 10));\n\n  this.onScan.emit(result);\n  this.manualInput.set('');\n}\n\nprivate validateManualInput(code: string): boolean {\n  const format = this.detectFormat(code);\n\n  if (!format) {\n    this.onError.emit({\n      type: 'invalid-format',\n      message: 'Unrecognized barcode format'\n    });\n    return false;\n  }\n\n  if (!this.formats().includes(format)) {\n    this.onError.emit({\n      type: 'invalid-format',\n      message: `Format ${format} not allowed`\n    });\n    return false;\n  }\n\n  return true;\n}\n\nprivate detectFormat(code: string): BarcodeFormat | null {\n  if (code.length === 13 && /^\\d+$/.test(code)) {\n    return 'ean13';\n  }\n  if (code.length === 8 && /^\\d+$/.test(code)) {\n    return 'ean8';\n  }\n  if (/^[A-Z0-9\\-\\.\\$\\/\\+% ]+$/.test(code)) {\n    return 'code128';\n  }\n  return null;\n}\n```\n\n**Acceptance Criteria:**\n- Manual input field works\n- Input validation implemented\n- Format detection works for common formats\n- Scan result emitted\n- Input cleared after successful scan\n\n**Dependencies:** 3.2.1\n\n---\n\n**[ ] Task 3.2.5: Implement beep sound and flashlight**\n\nAdd beep sound and flashlight control:\n\n```typescript\nprivate playBeep() {\n  try {\n    const audioContext = new AudioContext();\n    const oscillator = audioContext.createOscillator();\n    const gainNode = audioContext.createGain();\n\n    oscillator.connect(gainNode);\n    gainNode.connect(audioContext.destination);\n\n    oscillator.frequency.value = 800;\n    oscillator.type = 'sine';\n\n    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);\n    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);\n\n    oscillator.start(audioContext.currentTime);\n    oscillator.stop(audioContext.currentTime + 0.1);\n  } catch (error) {\n    // Audio not supported, fail silently\n  }\n}\n\nasync toggleFlashlight() {\n  const stream = this.currentStream();\n  if (!stream) return;\n\n  const track = stream.getVideoTracks()[0];\n  const capabilities: any = track.getCapabilities();\n\n  if (!capabilities.torch) {\n    this.onError.emit({\n      type: 'camera-error',\n      message: 'Flashlight not supported on this device'\n    });\n    return;\n  }\n\n  const enabled = !this.flashlightEnabled();\n  await track.applyConstraints({\n    advanced: [{ torch: enabled } as any]\n  });\n  this.flashlightEnabled.set(enabled);\n}\n```\n\n**Acceptance Criteria:**\n- Beep sound plays on successful scan\n- Flashlight toggles on supported devices\n- Graceful fallback when features unavailable\n\n**Dependencies:** 3.2.3\n\n---\n\n**[ ] Task 3.2.6: Create barcode-scanner template**\n\nImplement HTML template with camera and manual modes:\n\n**Acceptance Criteria:**\n- Template supports both camera and manual modes\n- Mode switcher works\n- Recent scans list displays\n- Responsive layout\n\n**Dependencies:** 3.2.5\n\n---\n\n**[ ] Task 3.2.7: Implement barcode-scanner styles**\n\nCreate SCSS styles following design:\n\n**Acceptance Criteria:**\n- Styles match design document\n- Video element properly sized\n- Scan frame overlay animated\n- Dark background for camera view\n\n**Dependencies:** 3.2.6\n\n---\n\n### 3.3 Testing\n\n**[ ] Task 3.3.1: Write unit tests for barcode-scanner**\n\nCreate comprehensive tests:\n\n```typescript\ndescribe('AxBarcodeScannerComponent', () => {\n  it('should create', () => {\n    expect(component).toBeTruthy();\n  });\n\n  it('should fallback to manual mode on permission denied', async () => {\n    spyOn(navigator.mediaDevices, 'getUserMedia').and.rejectWith(\n      new Error('Permission denied')\n    );\n\n    await component.initCameraMode();\n\n    expect(component.currentMode()).toBe('manual');\n  });\n\n  it('should emit scan event with correct format', () => {\n    const spy = jasmine.createSpy('onScan');\n    component.onScan.subscribe(spy);\n\n    component.manualInput.set('8850999320113');\n    component.onManualSubmit();\n\n    expect(spy).toHaveBeenCalledWith(\n      jasmine.objectContaining({\n        code: '8850999320113',\n        format: 'ean13',\n        mode: 'manual'\n      })\n    );\n  });\n\n  it('should detect EAN-13 format', () => {\n    expect(component.detectFormat('8850999320113')).toBe('ean13');\n  });\n\n  it('should detect EAN-8 format', () => {\n    expect(component.detectFormat('12345678')).toBe('ean8');\n  });\n\n  it('should validate allowed formats', () => {\n    component.formats.set(['ean13']);\n    expect(component.validateManualInput('8850999320113')).toBe(true);\n  });\n\n  it('should reject invalid format', () => {\n    component.formats.set(['ean13']);\n    const spy = jasmine.createSpy('onError');\n    component.onError.subscribe(spy);\n\n    component.validateManualInput('ABCD1234');\n\n    expect(spy).toHaveBeenCalled();\n  });\n\n  it('should store recent scans', () => {\n    component.manualInput.set('8850999320113');\n    component.onManualSubmit();\n\n    expect(component.recentScans().length).toBe(1);\n  });\n\n  it('should limit recent scans to 10', () => {\n    for (let i = 0; i < 15; i++) {\n      component.recentScans.update(scans => [\n        { code: `${i}`, format: 'qr', timestamp: new Date(), mode: 'manual' },\n        ...scans\n      ]);\n    }\n\n    expect(component.recentScans().length).toBeLessThanOrEqual(10);\n  });\n});\n```\n\n**Acceptance Criteria:**\n- All tests pass\n- Code coverage ≥80%\n- Camera permission tests included\n- Format detection tests included\n\n**Dependencies:** 3.2.7\n\n---\n\n## Phase 4: Quantity Input Component\n\n### 4.1 Types & Interfaces\n\n**[ ] Task 4.1.1: Create quantity-input.types.ts**\n\n```typescript\n/**\n * Validation error for quantity input\n */\nexport interface ValidationError {\n  type: 'min' | 'max' | 'decimal' | 'integer';\n  message: string;\n}\n\n/**\n * Validation state\n */\nexport interface ValidationState {\n  valid: boolean;\n  errors: ValidationError[];\n}\n```\n\n**Acceptance Criteria:**\n- Types documented with JSDoc\n- UnitConfig reused from shared inventory.types.ts\n- Types exported from index.ts\n\n**Dependencies:** 1.1.1, 1.1.3\n\n---\n\n### 4.2 Component Implementation\n\n**[ ] Task 4.2.1: Implement quantity-input scaffold**\n\nCreate component implementing ControlValueAccessor:\n\n```typescript\n@Component({\n  selector: 'ax-quantity-input',\n  standalone: true,\n  imports: [CommonModule, FormsModule, ReactiveFormsModule, MatSelectModule, MatIconModule],\n  providers: [{\n    provide: NG_VALUE_ACCESSOR,\n    useExisting: forwardRef(() => AxQuantityInputComponent),\n    multi: true\n  }],\n  templateUrl: './quantity-input.component.html',\n  styleUrls: ['./quantity-input.component.scss']\n})\nexport class AxQuantityInputComponent implements ControlValueAccessor {\n  // Two-way binding\n  value = model.required<number>();\n\n  // Inputs\n  baseUnit = input.required<string>();\n  availableUnits = input.required<UnitConfig[]>();\n  min = input<number>(0);\n  max = input<number>(Infinity);\n  step = input<number>(1);\n  showStepper = input<boolean>(true);\n  showPresets = input<boolean>(false);\n  decimalPlaces = input<number>(0);\n  disabled = input<boolean>(false);\n\n  // Outputs\n  valueChange = output<number>();\n  unitChange = output<string>();\n  onValidation = output<ValidationState>();\n\n  // Internal state\n  private selectedUnit = signal<string>('');\n  private isTouched = signal<boolean>(false);\n\n  // ControlValueAccessor\n  private onChange: (value: number) => void = () => {};\n  private onTouched: () => void = () => {};\n}\n```\n\n**Acceptance Criteria:**\n- Component implements ControlValueAccessor\n- All required inputs defined\n- NG_VALUE_ACCESSOR provider configured\n- Model signal for two-way binding\n\n**Dependencies:** 4.1.1\n\n---\n\n**[ ] Task 4.2.2: Implement unit conversion logic**\n\nAdd conversion computed signals:\n\n```typescript\nselectedUnitConfig = computed(() => {\n  const units = this.availableUnits();\n  const selected = this.selectedUnit();\n  return units.find(u => u.code === selected) || units[0];\n});\n\ndisplayValue = computed(() => {\n  const val = this.value();\n  const unit = this.selectedUnitConfig();\n  if (!unit) return val;\n  return val / unit.conversionRate;\n});\n\nconversionHint = computed(() => {\n  const val = this.value();\n  const baseUnit = this.baseUnit();\n  const currentUnit = this.selectedUnit();\n\n  if (currentUnit === baseUnit) return '';\n\n  const config = this.selectedUnitConfig();\n  if (!config) return '';\n\n  return `= ${val} ${baseUnit}  (${config.conversionRate} ${baseUnit} per ${config.label})`;\n});\n\nprivate convertToBaseUnit(displayValue: number, fromUnit: string): number {\n  const unitConfig = this.availableUnits().find(u => u.code === fromUnit);\n  if (!unitConfig) return displayValue;\n  return displayValue * unitConfig.conversionRate;\n}\n\nprivate convertFromBaseUnit(baseValue: number, toUnit: string): number {\n  const unitConfig = this.availableUnits().find(u => u.code === toUnit);\n  if (!unitConfig) return baseValue;\n  return baseValue / unitConfig.conversionRate;\n}\n\nonUnitChange(newUnit: string) {\n  this.selectedUnit.set(newUnit);\n  this.unitChange.emit(newUnit);\n}\n```\n\n**Acceptance Criteria:**\n- Conversion calculations correct\n- Display value updates when unit changes\n- Base value remains constant during unit changes\n- Conversion hint displays correctly\n\n**Dependencies:** 4.2.1\n\n---\n\n**[ ] Task 4.2.3: Implement validation logic**\n\nAdd validation computed signals:\n\n```typescript\nvalidationErrors = computed(() => {\n  const val = this.value();\n  const errors: ValidationError[] = [];\n\n  if (val < this.min()) {\n    errors.push({\n      type: 'min',\n      message: `Minimum value is ${this.min()}`\n    });\n  }\n\n  if (val > this.max()) {\n    errors.push({\n      type: 'max',\n      message: `Maximum value is ${this.max()}`\n    });\n  }\n\n  const dp = this.decimalPlaces();\n  const decimals = (val.toString().split('.')[1] || '').length;\n  if (decimals > dp) {\n    errors.push({\n      type: 'decimal',\n      message: `Maximum ${dp} decimal places`\n    });\n  }\n\n  const baseUnitConfig = this.availableUnits().find(u => u.code === this.baseUnit());\n  if (baseUnitConfig?.decimalPlaces === 0 && !Number.isInteger(val)) {\n    errors.push({\n      type: 'integer',\n      message: `${this.baseUnit()} must be a whole number`\n    });\n  }\n\n  return errors;\n});\n\nisValid = computed(() => this.validationErrors().length === 0);\n```\n\n**Acceptance Criteria:**\n- Min/max validation works\n- Decimal places validation works\n- Integer validation for whole-number units\n- Validation errors emitted via output\n\n**Dependencies:** 4.2.2\n\n---\n\n**[ ] Task 4.2.4: Implement stepper and preset logic**\n\nAdd increment/decrement and preset multipliers:\n\n```typescript\nincrement() {\n  if (this.disabled()) return;\n\n  const currentDisplay = this.displayValue();\n  const step = this.step();\n  const newDisplay = currentDisplay + step;\n\n  const newValue = this.convertToBaseUnit(newDisplay, this.selectedUnit());\n  this.updateValue(newValue);\n}\n\ndecrement() {\n  if (this.disabled()) return;\n\n  const currentDisplay = this.displayValue();\n  const step = this.step();\n  const newDisplay = Math.max(currentDisplay - step, 0);\n\n  const newValue = this.convertToBaseUnit(newDisplay, this.selectedUnit());\n  this.updateValue(newValue);\n}\n\nmultiplyValue(multiplier: number) {\n  if (this.disabled()) return;\n  const newValue = this.value() * multiplier;\n  this.updateValue(newValue);\n}\n\nprivate updateValue(newValue: number) {\n  const min = this.min();\n  const max = this.max();\n\n  const clampedValue = Math.max(min, Math.min(max, newValue));\n\n  const dp = this.decimalPlaces();\n  const roundedValue = Math.round(clampedValue * Math.pow(10, dp)) / Math.pow(10, dp);\n\n  this.value.set(roundedValue);\n  this.valueChange.emit(roundedValue);\n  this.onChange(roundedValue);\n\n  this.onValidation.emit({\n    valid: this.isValid(),\n    errors: this.validationErrors()\n  });\n}\n```\n\n**Acceptance Criteria:**\n- Increment/decrement buttons work\n- Values clamped to min/max\n- Decimal rounding applied\n- Preset multipliers (×10, ×100) work\n- Cannot go below minimum\n\n**Dependencies:** 4.2.3\n\n---\n\n**[ ] Task 4.2.5: Implement ControlValueAccessor methods**\n\nAdd forms integration:\n\n```typescript\nwriteValue(value: number): void {\n  this.value.set(value || 0);\n}\n\nregisterOnChange(fn: (value: number) => void): void {\n  this.onChange = fn;\n}\n\nregisterOnTouched(fn: () => void): void {\n  this.onTouched = fn;\n}\n\nsetDisabledState(isDisabled: boolean): void {\n  this.disabled.set(isDisabled);\n}\n\nonBlur() {\n  this.isTouched.set(true);\n  this.onTouched();\n}\n\nonInputChange(event: Event) {\n  const input = event.target as HTMLInputElement;\n  const displayValue = parseFloat(input.value) || 0;\n  const baseValue = this.convertToBaseUnit(displayValue, this.selectedUnit());\n  this.updateValue(baseValue);\n}\n```\n\n**Acceptance Criteria:**\n- Component works with FormControl\n- Component works with ngModel\n- Disabled state works\n- Touched state tracked\n- Value changes propagate to form\n\n**Dependencies:** 4.2.4\n\n---\n\n**[ ] Task 4.2.6: Create quantity-input template**\n\nImplement HTML template:\n\n**Acceptance Criteria:**\n- Stepper buttons render conditionally\n- Input field binds correctly\n- Unit dropdown works\n- Preset buttons appear conditionally\n- Conversion hint displays\n- Error messages show when invalid\n\n**Dependencies:** 4.2.5\n\n---\n\n**[ ] Task 4.2.7: Implement quantity-input styles**\n\nCreate SCSS styles:\n\n**Acceptance Criteria:**\n- Styles match design\n- Disabled state styled\n- Error state styled\n- Responsive layout\n\n**Dependencies:** 4.2.6\n\n---\n\n### 4.3 Testing\n\n**[ ] Task 4.3.1: Write unit tests for quantity-input**\n\nCreate comprehensive tests:\n\n```typescript\ndescribe('AxQuantityInputComponent', () => {\n  it('should convert between units correctly', () => {\n    component.baseUnit.set('pieces');\n    component.availableUnits.set([\n      { code: 'pieces', label: 'Pieces', conversionRate: 1, decimalPlaces: 0 },\n      { code: 'box', label: 'Box', conversionRate: 12, decimalPlaces: 0 }\n    ]);\n    component.selectedUnit.set('box');\n    component.value.set(144);\n\n    expect(component.displayValue()).toBe(12);\n  });\n\n  it('should increment value', () => {\n    component.value.set(10);\n    component.step.set(1);\n    component.increment();\n    expect(component.value()).toBe(11);\n  });\n\n  it('should decrement value', () => {\n    component.value.set(10);\n    component.step.set(1);\n    component.decrement();\n    expect(component.value()).toBe(9);\n  });\n\n  it('should not go below minimum', () => {\n    component.value.set(1);\n    component.min.set(0);\n    component.decrement();\n    expect(component.value()).toBeGreaterThanOrEqual(0);\n  });\n\n  it('should validate min value', () => {\n    component.min.set(10);\n    component.value.set(5);\n    expect(component.isValid()).toBe(false);\n    expect(component.validationErrors().some(e => e.type === 'min')).toBe(true);\n  });\n\n  it('should validate max value', () => {\n    component.max.set(100);\n    component.value.set(150);\n    expect(component.isValid()).toBe(false);\n    expect(component.validationErrors().some(e => e.type === 'max')).toBe(true);\n  });\n\n  it('should validate decimal places', () => {\n    component.decimalPlaces.set(2);\n    component.value.set(10.12345);\n    expect(component.validationErrors().some(e => e.type === 'decimal')).toBe(true);\n  });\n\n  it('should multiply by preset', () => {\n    component.value.set(10);\n    component.multiplyValue(10);\n    expect(component.value()).toBe(100);\n  });\n\n  it('should work with FormControl', () => {\n    const control = new FormControl(10);\n    component.writeValue(10);\n    expect(component.value()).toBe(10);\n  });\n});\n```\n\n**Acceptance Criteria:**\n- All tests pass\n- Code coverage ≥80%\n- Unit conversion tested\n- Validation tested\n- Forms integration tested\n\n**Dependencies:** 4.2.7\n\n---\n\n## Phase 5: Batch Selector Component\n\n### 5.1 Types & Interfaces\n\n**[ ] Task 5.1.1: Create batch-selector.types.ts**\n\n```typescript\n/**\n * Selected batch with quantity\n */\nexport interface SelectedBatch {\n  batch: BatchInfo;\n  quantity: number;\n}\n\n/**\n * Batch selection result\n */\nexport interface BatchSelection {\n  batches: SelectedBatch[];\n  totalQuantity: number;\n  strategy: InventoryStrategy;\n}\n\n/**\n * Expiry status\n */\nexport type ExpiryStatus = 'safe' | 'warning' | 'critical' | 'expired';\n```\n\n**Acceptance Criteria:**\n- Types documented\n- BatchInfo reused from shared types\n- Types exported from index.ts\n\n**Dependencies:** 1.1.1, 1.1.3\n\n---\n\n### 5.2 Component Implementation\n\n**[ ] Task 5.2.1: Implement batch-selector scaffold**\n\nCreate component structure:\n\n```typescript\n@Component({\n  selector: 'ax-batch-selector',\n  standalone: true,\n  imports: [\n    CommonModule,\n    FormsModule,\n    MatFormFieldModule,\n    MatInputModule,\n    MatSelectModule,\n    MatCheckboxModule,\n    MatRadioModule,\n    MatIconModule,\n    MatProgressSpinnerModule,\n    AxBadgeComponent,\n    AxQuantityInputComponent\n  ],\n  templateUrl: './batch-selector.component.html',\n  styleUrls: ['./batch-selector.component.scss']\n})\nexport class AxBatchSelectorComponent implements OnInit {\n  private readonly http = inject(HttpClient);\n\n  // Inputs\n  productId = input.required<string>();\n  batches = input<BatchInfo[]>([]);\n  strategy = model<InventoryStrategy>('fefo');\n  allowMultiple = input<boolean>(false);\n  requestedQuantity = input<number | undefined>(undefined);\n  showExpiry = input<boolean>(true);\n  showManufacturing = input<boolean>(false);\n  showRecommendation = input<boolean>(true);\n  expiryWarningDays = input<number>(30);\n  expiryCriticalDays = input<number>(7);\n\n  // Outputs\n  onSelect = output<BatchSelection>();\n  onBatchesLoad = output<BatchInfo[]>();\n  onError = output<string>();\n\n  // Internal state\n  private internalBatches = signal<BatchInfo[]>([]);\n  private selectedBatches = signal<SelectedBatch[]>([]);\n  private searchTerm = signal<string>('');\n  private isLoading = signal<boolean>(false);\n}\n```\n\n**Acceptance Criteria:**\n- Component compiles\n- HttpClient injected\n- All inputs/outputs defined\n- Internal state signals declared\n\n**Dependencies:** 5.1.1\n\n---\n\n**[ ] Task 5.2.2: Implement batch sorting strategies**\n\nAdd sorting logic:\n\n```typescript\nsortedBatches = computed(() => {\n  const batches = [...this.internalBatches()];\n  const strategy = this.strategy();\n\n  switch (strategy) {\n    case 'fifo':\n      return batches.sort((a, b) => {\n        const dateA = a.manufacturingDate?.getTime() || 0;\n        const dateB = b.manufacturingDate?.getTime() || 0;\n        return dateA - dateB;\n      });\n    case 'fefo':\n      return batches.sort((a, b) =>\n        a.expiryDate.getTime() - b.expiryDate.getTime()\n      );\n    case 'lifo':\n      return batches.sort((a, b) => {\n        const dateA = a.manufacturingDate?.getTime() || 0;\n        const dateB = b.manufacturingDate?.getTime() || 0;\n        return dateB - dateA;\n      });\n  }\n});\n\nfilteredBatches = computed(() => {\n  let batches = this.sortedBatches();\n  const term = this.searchTerm().toLowerCase();\n\n  if (term) {\n    batches = batches.filter(b =>\n      b.batchNumber.toLowerCase().includes(term) ||\n      b.lotNumber?.toLowerCase().includes(term)\n    );\n  }\n\n  return batches;\n});\n\nrecommendedBatchId = computed(() => {\n  if (!this.showRecommendation()) return null;\n\n  const available = this.sortedBatches().filter(b =>\n    b.status === 'available' && !this.isExpired(b)\n  );\n\n  return available[0]?.batchNumber || null;\n});\n```\n\n**Acceptance Criteria:**\n- FIFO sorts by manufacturing date ascending\n- FEFO sorts by expiry date ascending\n- LIFO sorts by manufacturing date descending\n- Search filters by batch/lot number\n- Recommended batch identified correctly\n\n**Dependencies:** 5.2.1\n\n---\n\n**[ ] Task 5.2.3: Implement expiry status logic**\n\nAdd expiry calculations:\n\n```typescript\ngetExpiryStatus(batch: BatchInfo): ExpiryStatus {\n  const now = new Date();\n  const expiry = new Date(batch.expiryDate);\n  const daysUntilExpiry = Math.ceil(\n    (expiry.getTime() - now.getTime()) / (1000 * 60 * 60 * 24)\n  );\n\n  if (daysUntilExpiry < 0) return 'expired';\n  if (daysUntilExpiry <= this.expiryCriticalDays()) return 'critical';\n  if (daysUntilExpiry <= this.expiryWarningDays()) return 'warning';\n  return 'safe';\n}\n\ngetExpiryBadgeText(batch: BatchInfo): string {\n  const status = this.getExpiryStatus(batch);\n  const now = new Date();\n  const expiry = new Date(batch.expiryDate);\n  const daysUntilExpiry = Math.ceil(\n    (expiry.getTime() - now.getTime()) / (1000 * 60 * 60 * 24)\n  );\n\n  switch (status) {\n    case 'expired':\n      return `EXPIRED ${Math.abs(daysUntilExpiry)} days ago`;\n    case 'critical':\n      return `${daysUntilExpiry} days left`;\n    case 'warning':\n      return `${daysUntilExpiry} days left`;\n    case 'safe':\n      return `Expires in ${daysUntilExpiry} days`;\n  }\n}\n\nisExpired(batch: BatchInfo): boolean {\n  return this.getExpiryStatus(batch) === 'expired';\n}\n\ncanSelectBatch(batch: BatchInfo): boolean {\n  return batch.status === 'available' && !this.isExpired(batch);\n}\n```\n\n**Acceptance Criteria:**\n- Expiry status calculated correctly\n- Badge text shows countdown\n- Expired batches identified\n- Unavailable batches cannot be selected\n\n**Dependencies:** 5.2.2\n\n---\n\n**[ ] Task 5.2.4: Implement batch selection logic**\n\nAdd selection handling:\n\n```typescript\ntotalSelectedQuantity = computed(() => {\n  return this.selectedBatches().reduce((sum, sb) => sum + sb.quantity, 0);\n});\n\ncanSelectMore = computed(() => {\n  if (!this.allowMultiple()) return true;\n  const requested = this.requestedQuantity();\n  if (!requested) return true;\n  return this.totalSelectedQuantity() < requested;\n});\n\nselectBatch(batch: BatchInfo, quantity?: number) {\n  if (!this.canSelectBatch(batch)) {\n    this.onError.emit(`Cannot select batch ${batch.batchNumber}: ${batch.status}`);\n    return;\n  }\n\n  const selected = this.selectedBatches();\n\n  if (this.allowMultiple()) {\n    const existing = selected.find(s => s.batch.batchNumber === batch.batchNumber);\n\n    if (existing) {\n      const newSelected = selected.map(s =>\n        s.batch.batchNumber === batch.batchNumber\n          ? { ...s, quantity: quantity || s.quantity }\n          : s\n      );\n      this.selectedBatches.set(newSelected);\n    } else {\n      const defaultQty = quantity || Math.min(\n        batch.availableQuantity,\n        (this.requestedQuantity() || batch.availableQuantity) - this.totalSelectedQuantity()\n      );\n\n      this.selectedBatches.set([...selected, { batch, quantity: defaultQty }]);\n    }\n  } else {\n    this.selectedBatches.set([{\n      batch,\n      quantity: quantity || batch.availableQuantity\n    }]);\n  }\n\n  this.emitSelection();\n}\n\ndeselectBatch(batchNumber: string) {\n  const selected = this.selectedBatches().filter(\n    s => s.batch.batchNumber !== batchNumber\n  );\n  this.selectedBatches.set(selected);\n  this.emitSelection();\n}\n\nisSelected(batch: BatchInfo): boolean {\n  return this.selectedBatches().some(\n    s => s.batch.batchNumber === batch.batchNumber\n  );\n}\n\nupdateBatchQuantity(batch: BatchInfo, quantity: number) {\n  const selected = this.selectedBatches().map(s =>\n    s.batch.batchNumber === batch.batchNumber\n      ? { ...s, quantity }\n      : s\n  );\n  this.selectedBatches.set(selected);\n  this.emitSelection();\n}\n\nprivate emitSelection() {\n  const selection: BatchSelection = {\n    batches: this.selectedBatches(),\n    totalQuantity: this.totalSelectedQuantity(),\n    strategy: this.strategy()\n  };\n  this.onSelect.emit(selection);\n}\n```\n\n**Acceptance Criteria:**\n- Single-select mode works\n- Multi-select mode works\n- Quantity per batch can be specified\n- Total quantity calculated correctly\n- Cannot exceed requested quantity\n- Selection state tracked\n\n**Dependencies:** 5.2.3\n\n---\n\n**[ ] Task 5.2.5: Implement API integration**\n\nAdd batch loading from API:\n\n```typescript\nprivate readonly apiUrl = '/api/inventory/products';\n\nasync ngOnInit() {\n  if (!this.batches().length && this.productId()) {\n    await this.loadBatches();\n  } else {\n    this.internalBatches.set(this.batches());\n  }\n}\n\nprivate async loadBatches() {\n  this.isLoading.set(true);\n\n  try {\n    const response = await firstValueFrom(\n      this.http.get<{ batches: BatchInfo[], strategy: string }>(\n        `${this.apiUrl}/${this.productId()}/batches`,\n        {\n          params: {\n            status: 'available'\n          }\n        }\n      )\n    );\n\n    this.internalBatches.set(response.batches);\n    this.onBatchesLoad.emit(response.batches);\n\n    if (response.strategy) {\n      this.strategy.set(response.strategy as InventoryStrategy);\n    }\n  } catch (error: any) {\n    this.onError.emit(`Failed to load batches: ${error.message}`);\n  } finally {\n    this.isLoading.set(false);\n  }\n}\n```\n\n**Acceptance Criteria:**\n- API called on init if no batches provided\n- Loading state shown during fetch\n- Error handled gracefully\n- Batches loaded and sorted\n- Strategy from API applied\n\n**Dependencies:** 5.2.4\n\n---\n\n**[ ] Task 5.2.6: Create batch-selector template**\n\nImplement HTML template with batch cards:\n\n**Acceptance Criteria:**\n- Search input works\n- Strategy selector works\n- Batch cards display all information\n- Loading state shown\n- Empty state shown\n- Selected batches summary shown\n\n**Dependencies:** 5.2.5\n\n---\n\n**[ ] Task 5.2.7: Implement batch-selector styles**\n\nCreate SCSS styles:\n\n**Acceptance Criteria:**\n- Card layout responsive\n- Expiry badges color-coded\n- Recommended batch highlighted\n- Selected batch highlighted\n- Disabled/expired batches grayed out\n\n**Dependencies:** 5.2.6\n\n---\n\n### 5.3 Testing\n\n**[ ] Task 5.3.1: Write unit tests for batch-selector**\n\nCreate comprehensive tests:\n\n```typescript\ndescribe('AxBatchSelectorComponent', () => {\n  it('should sort batches by FEFO', () => {\n    component.strategy.set('fefo');\n    component.internalBatches.set([\n      { batchNumber: 'B1', expiryDate: new Date('2025-06-01'), ...mockBatch },\n      { batchNumber: 'B2', expiryDate: new Date('2025-03-01'), ...mockBatch },\n      { batchNumber: 'B3', expiryDate: new Date('2025-09-01'), ...mockBatch },\n    ]);\n\n    const sorted = component.sortedBatches();\n    expect(sorted[0].batchNumber).toBe('B2');\n  });\n\n  it('should calculate expiry status correctly', () => {\n    const safeBatch = {\n      ...mockBatch,\n      expiryDate: new Date(Date.now() + 60 * 24 * 60 * 60 * 1000)\n    };\n    expect(component.getExpiryStatus(safeBatch)).toBe('safe');\n\n    const warningBatch = {\n      ...mockBatch,\n      expiryDate: new Date(Date.now() + 15 * 24 * 60 * 60 * 1000)\n    };\n    expect(component.getExpiryStatus(warningBatch)).toBe('warning');\n\n    const criticalBatch = {\n      ...mockBatch,\n      expiryDate: new Date(Date.now() + 5 * 24 * 60 * 60 * 1000)\n    };\n    expect(component.getExpiryStatus(criticalBatch)).toBe('critical');\n  });\n\n  it('should select batch in single-select mode', () => {\n    component.allowMultiple.set(false);\n    component.selectBatch(mockBatch);\n    expect(component.selectedBatches().length).toBe(1);\n  });\n\n  it('should allow multiple batches in multi-select mode', () => {\n    component.allowMultiple.set(true);\n    component.selectBatch(mockBatch1);\n    component.selectBatch(mockBatch2);\n    expect(component.selectedBatches().length).toBe(2);\n  });\n\n  it('should calculate total quantity', () => {\n    component.selectedBatches.set([\n      { batch: mockBatch1, quantity: 50 },\n      { batch: mockBatch2, quantity: 75 }\n    ]);\n    expect(component.totalSelectedQuantity()).toBe(125);\n  });\n\n  it('should recommend first available batch', () => {\n    component.internalBatches.set([\n      { ...mockBatch1, batchNumber: 'B1', status: 'available' },\n      { ...mockBatch2, batchNumber: 'B2', status: 'available' }\n    ]);\n    expect(component.recommendedBatchId()).toBe('B1');\n  });\n\n  it('should filter by search term', () => {\n    component.internalBatches.set([\n      { ...mockBatch, batchNumber: 'BATCH-001' },\n      { ...mockBatch, batchNumber: 'BATCH-002' }\n    ]);\n    component.searchTerm.set('001');\n    expect(component.filteredBatches().length).toBe(1);\n  });\n});\n```\n\n**Acceptance Criteria:**\n- All tests pass\n- Code coverage ≥80%\n- Sorting strategies tested\n- Expiry calculations tested\n- Selection logic tested\n\n**Dependencies:** 5.2.7\n\n---\n\n## Phase 6: Integration & Testing\n\n### 6.1 Component Integration\n\n**[ ] Task 6.1.1: Create example integration page**\n\nCreate demo page showing all components working together:\n\n**Acceptance Criteria:**\n- Stock receive flow example\n- All 4 components integrated\n- Data flows between components\n- Form validation works end-to-end\n\n**Dependencies:** 2.3.2, 3.3.1, 4.3.1, 5.3.1\n\n---\n\n**[ ] Task 6.1.2: Write integration tests**\n\nCreate integration tests for component interactions:\n\n**Acceptance Criteria:**\n- Full stock receive flow tested\n- Component communication tested\n- State management tested\n- API integration tested\n\n**Dependencies:** 6.1.1\n\n---\n\n### 6.2 E2E Testing\n\n**[ ] Task 6.2.1: Write Playwright E2E tests**\n\nCreate end-to-end tests:\n\n```typescript\ntest('Complete stock receive flow', async ({ page }) => {\n  await page.goto('/inventory/receive');\n\n  // Scan barcode\n  await page.click('[data-testid=\"barcode-scanner-trigger\"]');\n  await page.fill('input[placeholder=\"Enter barcode...\"]', '8850999320113');\n  await page.press('input[placeholder=\"Enter barcode...\"]', 'Enter');\n\n  // Select batch\n  await page.click('[data-testid=\"batch-card\"]:first-child');\n\n  // Enter quantity\n  await page.fill('input[aria-label=\"Quantity\"]', '100');\n\n  // Verify stock preview\n  const preview = await page.textContent('[data-testid=\"stock-preview\"]');\n  expect(preview).toContain('200'); // Assuming current was 100\n\n  // Submit\n  await page.click('button[type=\"submit\"]');\n\n  // Verify success\n  await expect(page.locator('.toast-success')).toBeVisible();\n});\n```\n\n**Acceptance Criteria:**\n- E2E test covers full flow\n- Tests run in CI/CD\n- Screenshots on failure\n- Tests pass consistently\n\n**Dependencies:** 6.1.2\n\n---\n\n### 6.3 Performance Testing\n\n**[ ] Task 6.3.1: Measure component performance**\n\nTest component rendering and bundle size:\n\n**Acceptance Criteria:**\n- Stock Level: <100ms render, <5KB gzipped\n- Barcode Scanner: <500ms camera init, <25KB gzipped (with ZXing lazy loaded)\n- Quantity Input: <100ms render, <8KB gzipped\n- Batch Selector: <300ms API + render, <15KB gzipped\n- All components meet performance targets\n\n**Dependencies:** 6.2.1\n\n---\n\n**[ ] Task 6.3.2: Optimize bundle sizes**\n\nApply optimizations if needed:\n\n**Acceptance Criteria:**\n- Lazy loading implemented for ZXing\n- Tree shaking verified\n- No duplicate dependencies\n- Code splitting effective\n\n**Dependencies:** 6.3.1\n\n---\n\n## Phase 7: Documentation & Deployment\n\n### 7.1 Component Documentation\n\n**[ ] Task 7.1.1: Write API documentation**\n\nDocument each component's public API:\n\n**Acceptance Criteria:**\n- All inputs/outputs documented\n- Usage examples provided\n- Type definitions linked\n- Accessibility notes included\n\n**Dependencies:** 6.3.2\n\n---\n\n**[ ] Task 7.1.2: Create Storybook stories**\n\nAdd interactive documentation:\n\n**Acceptance Criteria:**\n- Story for each component\n- Multiple examples per component\n- Controls for all inputs\n- Accessibility checks pass\n\n**Dependencies:** 7.1.1\n\n---\n\n**[ ] Task 7.1.3: Update changelog**\n\nDocument new components in CHANGELOG:\n\n**Acceptance Criteria:**\n- Version bumped appropriately\n- All 4 components listed under \"Added\"\n- Breaking changes noted (if any)\n- Migration guide provided (if needed)\n\n**Dependencies:** 7.1.2\n\n---\n\n### 7.2 Deployment\n\n**[ ] Task 7.2.1: Build and test production bundle**\n\n**Acceptance Criteria:**\n- `pnpm nx build aegisx-ui` succeeds\n- No build warnings\n- Bundle analysis clean\n- Types generated correctly\n\n**Dependencies:** 7.1.3\n\n---\n\n**[ ] Task 7.2.2: Publish to npm (if standalone library)**\n\n**Acceptance Criteria:**\n- Version number correct\n- All files included in package\n- README updated\n- Published successfully\n\n**Dependencies:** 7.2.1\n\n---\n\n**[ ] Task 7.2.3: Update project documentation**\n\nUpdate main project docs:\n\n**Acceptance Criteria:**\n- Component catalog updated\n- Type catalog includes new types\n- Index.ts exports verified\n- Examples in documentation\n\n**Dependencies:** 7.2.2\n\n---\n\n## Summary\n\n**Total Tasks:** 85\n**Estimated Duration:** 4 weeks (with parallel work)\n\n### Task Breakdown by Phase:\n- Phase 1 (Foundation): 4 tasks\n- Phase 2 (Stock Level): 8 tasks\n- Phase 3 (Barcode Scanner): 13 tasks\n- Phase 4 (Quantity Input): 14 tasks\n- Phase 5 (Batch Selector): 16 tasks\n- Phase 6 (Integration & Testing): 8 tasks\n- Phase 7 (Documentation): 6 tasks\n\n### Critical Path:\n1. Foundation setup (1.1.1 → 1.1.2 → 1.1.3 → 1.1.4)\n2. Component implementation (parallel after foundation)\n3. Integration testing (after all components done)\n4. Documentation and deployment\n\n---\n\n*Tasks Version: 1.0*\n*Last Updated: 2025-12-18*\n*Status: Ready for Implementation*\n",
  "fileStats": {
    "size": 51792,
    "lines": 2197,
    "lastModified": "2025-12-18T16:53:00.131Z"
  },
  "comments": []
}
