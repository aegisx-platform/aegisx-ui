name: Automated Release

on:
  push:
    branches:
      - main

permissions:
  contents: write
  packages: write
  pull-requests: write
  issues: write

jobs:
  check-conventional-commits:
    name: Check for Release
    runs-on: ubuntu-latest
    outputs:
      should_release: ${{ steps.check.outputs.should_release }}
      version_bump: ${{ steps.check.outputs.version_bump }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check commit messages
        id: check
        run: |
          # Get commits since last tag
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          
          if [ -z "$LAST_TAG" ]; then
            echo "No tags found, checking all commits"
            COMMITS=$(git log --pretty=format:"%s" --no-merges)
          else
            echo "Last tag: $LAST_TAG"
            COMMITS=$(git log ${LAST_TAG}..HEAD --pretty=format:"%s" --no-merges)
          fi
          
          # Check for conventional commits
          HAS_BREAKING=false
          HAS_FEAT=false
          HAS_FIX=false
          
          while IFS= read -r commit; do
            echo "Checking: $commit"
            if [[ "$commit" =~ ^.*BREAKING[[:space:]]CHANGE:|^.*!: ]]; then
              HAS_BREAKING=true
            elif [[ "$commit" =~ ^feat(\(.*\))?:[[:space:]] ]]; then
              HAS_FEAT=true
            elif [[ "$commit" =~ ^fix(\(.*\))?:[[:space:]] ]]; then
              HAS_FIX=true
            fi
          done <<< "$COMMITS"
          
          # Determine version bump
          if [ "$HAS_BREAKING" = true ]; then
            VERSION_BUMP="major"
            SHOULD_RELEASE=true
          elif [ "$HAS_FEAT" = true ]; then
            VERSION_BUMP="minor"
            SHOULD_RELEASE=true
          elif [ "$HAS_FIX" = true ]; then
            VERSION_BUMP="patch"
            SHOULD_RELEASE=true
          else
            VERSION_BUMP="none"
            SHOULD_RELEASE=false
          fi
          
          echo "should_release=$SHOULD_RELEASE" >> $GITHUB_OUTPUT
          echo "version_bump=$VERSION_BUMP" >> $GITHUB_OUTPUT
          echo "Version bump: $VERSION_BUMP"

  create-release:
    name: Create Release
    needs: check-conventional-commits
    if: needs.check-conventional-commits.outputs.should_release == 'true'
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'yarn'

      - name: Install dependencies
        run: yarn install --frozen-lockfile

      - name: Configure Git
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

      - name: Install changelog generator
        run: |
          npm install -g conventional-changelog-cli
          npm install -g standard-version

      - name: Generate version and changelog
        id: version
        run: |
          # Use standard-version for automatic versioning and changelog
          npx standard-version --release-as ${{ needs.check-conventional-commits.outputs.version_bump }} --no-verify
          
          # Get the new version
          NEW_VERSION=$(node -p "require('./package.json').version")
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          
          # Extract latest changelog entry
          sed -n '/^## \[/,/^## \[/p' CHANGELOG.md | sed '$d' > LATEST_CHANGELOG.md
          
          echo "Generated version: $NEW_VERSION"

      - name: Update workspace versions
        run: |
          # Update all workspace package.json files
          NEW_VERSION=${{ steps.version.outputs.new_version }}
          
          # Update apps
          for app in api web admin; do
            if [ -f "apps/$app/package.json" ]; then
              jq ".version = \"$NEW_VERSION\"" "apps/$app/package.json" > tmp.json && mv tmp.json "apps/$app/package.json"
            fi
          done
          
          # Update libs if any
          if [ -d "libs" ]; then
            find libs -name "package.json" -type f | while read -r pkg; do
              jq ".version = \"$NEW_VERSION\"" "$pkg" > tmp.json && mv tmp.json "$pkg"
            done
          fi

      - name: Commit changes
        run: |
          git add .
          git commit --amend --no-edit
          git tag -f v${{ steps.version.outputs.new_version }}

      - name: Push changes
        run: |
          git push origin main --follow-tags --force-with-lease

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ steps.version.outputs.new_version }}
          name: v${{ steps.version.outputs.new_version }}
          body_path: LATEST_CHANGELOG.md
          draft: false
          prerelease: false
          generate_release_notes: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Trigger deployment workflow
        uses: peter-evans/repository-dispatch@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          event-type: deploy-production
          client-payload: '{"version": "v${{ steps.version.outputs.new_version }}"}'

      - name: Notify release
        uses: 8398a7/action-slack@v3
        with:
          status: success
          channel: '#releases'
          text: |
            üöÄ New release *v${{ steps.version.outputs.new_version }}* has been created!
            üìù Changelog: ${{ github.server_url }}/${{ github.repository }}/releases/tag/v${{ steps.version.outputs.new_version }}
            üê≥ Docker images are being built...
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        if: success() && env.SLACK_WEBHOOK_URL != ''