# Test Products - Reference Implementation

> **Purpose**: test-products is the gold standard for CRUD generator output. This document details its structure and patterns that templates should follow.

## Overview

**test-products** was generated by CRUD Generator and then refined to establish the correct patterns. All CRUD generator templates should produce output matching these patterns.

## File Locations

```
Frontend: apps/web/src/app/features/test-products/
Backend:  apps/api/src/modules/testProducts/
Database: apps/api/src/database/migrations/014_create_test_tables.ts
```

## Frontend Structure (`apps/web/src/app/features/test-products/`)

```
test-products/
├── components/
│   ├── test-products-list.component.ts      # Main list with table
│   ├── test-products-create.dialog.ts       # Create dialog
│   ├── test-products-edit.dialog.ts         # Edit dialog
│   ├── test-products-view.dialog.ts         # View details dialog
│   ├── test-products-delete.dialog.ts       # Delete confirmation
│   └── test-products-import.dialog.ts       # Import Excel/CSV
├── services/
│   └── test-products.service.ts             # HTTP API service
├── types/
│   └── test-products.types.ts               # TypeScript interfaces
├── test-products.routes.ts                  # Route configuration
└── index.ts                                 # Exports
```

### List Component Patterns

```typescript
// Signals for state management
items = signal<TestProduct[]>([]);
loading = signal(false);
totalItems = signal(0);

// Pagination signals
pageIndex = signal(0);
pageSize = signal(10);

// Filter signals
searchQuery = signal('');
statusFilter = signal<string | null>(null);

// Computed for filtered data
filteredItems = computed(() => {
  // filter logic
});
```

**Table columns pattern:**

```typescript
displayedColumns = ['select', 'name', 'sku', 'price', 'status', 'actions'];
```

### Dialog Patterns

**Create Dialog Header:**

```html
<h2 mat-dialog-title class="ax-header ax-header-gradient-info">
  <div class="ax-icon-info">
    <mat-icon>add_circle</mat-icon>
  </div>
  <div class="header-text">
    <div class="ax-title">เพิ่มสินค้าทดสอบ</div>
    <div class="ax-subtitle">กรอกข้อมูลสินค้าใหม่</div>
  </div>
  <button mat-icon-button mat-dialog-close class="!absolute top-2 right-2">
    <mat-icon>close</mat-icon>
  </button>
</h2>
```

**Edit Dialog Header:**

```html
<h2 mat-dialog-title class="ax-header ax-header-gradient-warning">
  <div class="ax-icon-warning">
    <mat-icon>edit</mat-icon>
  </div>
  <!-- ... -->
</h2>
```

**Delete Dialog Header:**

```html
<h2 mat-dialog-title class="ax-header ax-header-gradient-error">
  <div class="ax-icon-error">
    <mat-icon>delete</mat-icon>
  </div>
  <!-- ... -->
</h2>
```

**View Dialog Header:**

```html
<h2 mat-dialog-title class="ax-header ax-header-gradient-info">
  <div class="ax-icon-info">
    <mat-icon>visibility</mat-icon>
  </div>
  <!-- ... -->
</h2>
```

### Form Section Pattern

```html
<mat-dialog-content>
  <!-- Section 1: Basic Info -->
  <div class="ax-dialog-section">
    <h3 class="ax-dialog-section-title">ข้อมูลพื้นฐาน</h3>
    <div class="ax-dialog-section-content">
      <div class="grid grid-cols-2 gap-4">
        <mat-form-field appearance="outline">
          <mat-label>ชื่อสินค้า</mat-label>
          <input matInput formControlName="name" />
        </mat-form-field>
        <!-- more fields -->
      </div>
    </div>
  </div>

  <!-- Section 2: Pricing -->
  <div class="ax-dialog-section">
    <h3 class="ax-dialog-section-title">ราคาและสต็อก</h3>
    <!-- fields -->
  </div>
</mat-dialog-content>
```

### View Dialog Field Pattern

```html
<div class="ax-dialog-field-row">
  <span class="ax-dialog-field-label">ชื่อสินค้า</span>
  <span class="ax-dialog-field-value">{{ data.name }}</span>
</div>

<div class="ax-dialog-field-row">
  <span class="ax-dialog-field-label">สถานะ</span>
  <span class="ax-dialog-field-value">
    <span class="ax-badge" [class]="getStatusClass(data.status)"> {{ data.status }} </span>
  </span>
</div>
```

### Dialog Actions Pattern

```html
<div mat-dialog-actions align="end" class="!px-6 !py-4">
  <button mat-button mat-dialog-close>ยกเลิก</button>
  <button mat-flat-button color="primary" [disabled]="form.invalid || saving()" (click)="save()">
    @if (saving()) {
    <mat-spinner diameter="20"></mat-spinner>
    } @else { บันทึก }
  </button>
</div>
```

### Service Pattern

```typescript
@Injectable({ providedIn: 'root' })
export class TestProductsService {
  private http = inject(HttpClient);
  private baseUrl = '/api/test-products';

  getAll(params?: QueryParams): Observable<PaginatedResponse<TestProduct>> {
    return this.http.get<PaginatedResponse<TestProduct>>(this.baseUrl, { params });
  }

  getById(id: string): Observable<TestProduct> {
    return this.http.get<TestProduct>(`${this.baseUrl}/${id}`);
  }

  create(data: CreateTestProduct): Observable<TestProduct> {
    return this.http.post<TestProduct>(this.baseUrl, data);
  }

  update(id: string, data: UpdateTestProduct): Observable<TestProduct> {
    return this.http.patch<TestProduct>(`${this.baseUrl}/${id}`, data);
  }

  delete(id: string): Observable<void> {
    return this.http.delete<void>(`${this.baseUrl}/${id}`);
  }
}
```

## Backend Structure (`apps/api/src/modules/testProducts/`)

```
testProducts/
├── testProducts.controller.ts    # Route handlers
├── testProducts.service.ts       # Business logic
├── testProducts.repository.ts    # Database queries
├── testProducts.schemas.ts       # TypeBox validation
├── testProducts.routes.ts        # Route registration
├── testProducts.types.ts         # TypeScript types
├── testProducts.events.ts        # WebSocket events
├── testProducts.import.service.ts # Import service
└── index.ts                      # Exports
```

### Controller Pattern

```typescript
export class TestProductsController {
  constructor(private service: TestProductsService) {}

  async findAll(request: FastifyRequest<{ Querystring: PaginationQuery }>, reply: FastifyReply) {
    const result = await this.service.findAll(request.query);
    return reply.send(result);
  }

  async findById(request: FastifyRequest<{ Params: { id: string } }>, reply: FastifyReply) {
    const item = await this.service.findById(request.params.id);
    if (!item) {
      return reply.notFound('Test product not found');
    }
    return reply.send(item);
  }

  async create(request: FastifyRequest<{ Body: CreateTestProduct }>, reply: FastifyReply) {
    const item = await this.service.create(request.body, request.user?.id);
    return reply.status(201).send(item);
  }
}
```

### Service Pattern (extends BaseService)

```typescript
export class TestProductsService extends BaseService<TestProduct, CreateTestProduct, UpdateTestProduct> {
  constructor(repository: TestProductsRepository, eventEmitter?: EventEmitter) {
    super(repository, 'test_products', eventEmitter);
  }

  // Custom business logic methods can be added here
  async findByCategory(categoryId: string) {
    return this.repository.findByField('category_id', categoryId);
  }
}
```

### Repository Pattern (extends BaseRepository)

```typescript
export class TestProductsRepository extends BaseRepository<TestProduct, CreateTestProduct, UpdateTestProduct> {
  constructor(knex: Knex) {
    super(
      knex,
      'test_products',
      ['name', 'sku', 'description'], // searchable fields
      ['id', 'category_id', 'created_by'], // UUID fields
    );
  }
}
```

### Schema Pattern (TypeBox)

```typescript
// Base schema (for response)
export const TestProductSchema = Type.Object({
  id: Type.String({ format: 'uuid' }),
  name: Type.String(),
  sku: Type.String(),
  price: Type.Number(),
  status: Type.Union([Type.Literal('active'), Type.Literal('inactive'), Type.Literal('draft')]),
  created_at: Type.String({ format: 'date-time' }),
  updated_at: Type.String({ format: 'date-time' }),
});

// Create schema (for request body)
export const CreateTestProductSchema = Type.Object({
  name: Type.String({ minLength: 1 }),
  sku: Type.String({ minLength: 1 }),
  price: Type.Number({ minimum: 0 }),
  status: Type.Optional(Type.Union([Type.Literal('active'), Type.Literal('inactive'), Type.Literal('draft')])),
});

// Update schema (all fields optional)
export const UpdateTestProductSchema = Type.Partial(CreateTestProductSchema);

// Export types
export type TestProduct = Static<typeof TestProductSchema>;
export type CreateTestProduct = Static<typeof CreateTestProductSchema>;
export type UpdateTestProduct = Static<typeof UpdateTestProductSchema>;
```

### Routes Pattern

```typescript
export async function testProductsRoutes(fastify: FastifyInstance) {
  const repository = new TestProductsRepository(fastify.knex);
  const service = new TestProductsService(repository, fastify.eventEmitter);
  const controller = new TestProductsController(service);

  // List with pagination
  fastify.get(
    '/',
    {
      schema: {
        querystring: PaginationQuerySchema,
        response: { 200: PaginatedResponseSchema(TestProductSchema) },
      },
      preValidation: [fastify.verifyJWT],
    },
    controller.findAll.bind(controller),
  );

  // Get by ID
  fastify.get(
    '/:id',
    {
      schema: {
        params: IdParamSchema,
        response: { 200: TestProductSchema },
      },
      preValidation: [fastify.verifyJWT],
    },
    controller.findById.bind(controller),
  );

  // Create
  fastify.post(
    '/',
    {
      schema: {
        body: CreateTestProductSchema,
        response: { 201: TestProductSchema },
      },
      preValidation: [fastify.verifyJWT, fastify.verifyPermission('test_products.create')],
    },
    controller.create.bind(controller),
  );
}
```

## Database Migration

```typescript
// 014_create_test_tables.ts
export async function up(knex: Knex): Promise<void> {
  // Skip in production
  if (process.env.NODE_ENV === 'production') return;

  await knex.schema.createTable('test_categories', (table) => {
    table.uuid('id').primary().defaultTo(knex.raw('gen_random_uuid()'));
    table.string('name').notNullable();
    table.text('description');
    table.timestamps(true, true);
  });

  await knex.schema.createTable('test_products', (table) => {
    table.uuid('id').primary().defaultTo(knex.raw('gen_random_uuid()'));
    table.string('name').notNullable();
    table.string('sku').unique().notNullable();
    table.decimal('price', 10, 2).defaultTo(0);
    table.uuid('category_id').references('id').inTable('test_categories');
    table.enum('status', ['active', 'inactive', 'draft']).defaultTo('draft');
    table.uuid('created_by').references('id').inTable('users');
    table.timestamps(true, true);
    table.timestamp('deleted_at'); // soft delete
  });
}
```

## Key Takeaways

1. **Use aegisx-ui CSS classes** - `ax-header`, `ax-icon-*`, `ax-dialog-section`, etc.
2. **Use Angular Signals** - Not BehaviorSubject or traditional state
3. **Extend Base classes** - BaseService, BaseRepository for consistency
4. **TypeBox for schemas** - Both validation and type generation
5. **Thai language UI** - Labels and messages in Thai
6. **Consistent dialog structure** - Header with icon, sections, actions

---

_Last Updated: Session 73 - CSS Token Migration_
