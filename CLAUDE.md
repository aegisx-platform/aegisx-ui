# Enterprise Monorepo Application

> **ğŸ“š Complete documentation has been split into organized files in the `docs/` directory for better readability.**

## ğŸš¨ Important Development Guidelines

### ğŸš¨ CRITICAL: Multi-Instance Port Configuration

**This project uses AUTOMATIC port assignment based on folder name.**

**Setup Process (User runs this BEFORE starting development):**

```bash
pnpm run setup
# This runs: setup-env.sh â†’ generates .env.local with unique ports
#            docker:up â†’ starts containers
#            db:migrate â†’ runs migrations
#            db:seed â†’ seeds database
```

**How Ports Are Assigned (from setup-env.sh):**

- Folder `aegisx-starter` â†’ Default ports (API: 3333, PostgreSQL: 5432)
- Folder `aegisx-starter-1` â†’ Hash("1") = 49 â†’ API: 3383, PostgreSQL: 5482
- Folder `aegisx-starter-xyz` â†’ Hash("xyz") â†’ Unique ports calculated
- **Each folder gets DIFFERENT ports automatically**

**NEVER modify these generated files:**

- `.env.local` - Auto-generated by setup-env.sh
- `docker-compose.instance.yml` - Auto-generated by setup-env.sh
- `proxy.conf.js` - Reads from .env.local automatically

**How to Find Current Ports:**

```bash
# ALWAYS do this FIRST before any port-related operation
cat .env.local | grep PORT
```

**MANDATORY Rules:**

1. **User runs `pnpm run setup` FIRST** - Generates .env.local with correct ports
2. **ALWAYS read `.env.local`** before any operation - Don't assume ANY port
3. **Use `pnpm run dev:api`** - Reads from .env.local automatically via load-env.sh
4. **NEVER hardcode ports** - setup-env.sh calculates them from folder name
5. **If port conflict**: User must stop conflicting service, DON'T change .env.local

**Common Mistakes to AVOID:**

- âŒ Assuming API is on 3333 (depends on folder name hash)
- âŒ Running `nx serve api --port 3333` (bypasses .env.local)
- âŒ Modifying .env.local manually (breaks multi-instance setup)
- âœ… User runs `pnpm run setup` first
- âœ… Use `pnpm run dev:api` (respects .env.local)
- âœ… Check ports: `cat .env.local | grep PORT`

**Why This Matters:**

- User runs multiple repos: aegisx-starter, aegisx-starter-1, aegisx-starter-feature-x
- setup-env.sh assigns unique ports based on folder name hash
- Wrong port = data goes to wrong database = DATA CORRUPTION
- Modifying .env.local breaks the automatic port assignment system

### ğŸš¨ CRITICAL: Standard Development Policy

**NEVER make changes without explicit user approval**

- **DO NOT add/modify standards without asking first**
- **DO NOT extend checklists or create new verification steps**
- **DO NOT write code or configs based on assumptions**
- **ALWAYS ask user before adding new requirements**

**When encountering gaps in standards:**

1. **STOP development**
2. **Ask user:** "Found [issue]. Should we create standard for this?"
3. **Wait for explicit approval and direction**
4. **Create standard only as instructed by user**

**Examples of what requires user approval:**

- Adding new checklist items
- Creating new verification scripts
- Extending existing standards
- Adding new phase/step requirements
- Modifying workflow processes

### Git Commit Rules

**DO NOT include the following in git commits**:

- `ğŸ¤– Generated with Claude Code`
- `Co-Authored-By: Claude <noreply@anthropic.com>`

Keep commit messages clean and professional.

### ğŸš¨ CRITICAL: Semantic Release Protection Policy

**FORBIDDEN PATTERNS IN COMMIT MESSAGES - WILL TRIGGER v2.x.x RELEASES:**

- **NEVER use "BREAKING CHANGE:" in commit messages**
- **NEVER use "BREAKING CHANGES:" in commit messages**
- **NEVER use "BREAKING:" in commit messages**
- **NEVER copy commit messages from other repositories without reviewing**

**SAFE ALTERNATIVES to use instead:**

- `IMPORTANT:` - For significant changes that need attention
- `MAJOR UPDATE:` - For substantial feature changes
- `SIGNIFICANT:` - For notable modifications
- `API CHANGE:` - For API modifications that maintain compatibility
- `MIGRATION:` - For database or configuration changes
- `DEPRECATED:` - For marking features as deprecated

**VERSION STRATEGY:**

- Project maintains **v1.x.x versioning only**
- Major version (v2.x.x) releases are **FORBIDDEN**
- All changes must be backward compatible
- Use minor/patch releases for all updates

**COMMIT MESSAGE REVIEW CHECKLIST:**

1. âœ… No "BREAKING CHANGE" text anywhere in commit
2. âœ… No "BREAKING CHANGES" text anywhere in commit
3. âœ… No "BREAKING:" text anywhere in commit
4. âœ… Use safe alternatives for significant changes
5. âœ… Conventional commit format: `type(scope): description`

**IF ACCIDENTAL BREAKING CHANGE COMMIT:**

1. **STOP immediately** - Do not push
2. Use `git commit --amend` to fix message
3. If already pushed, contact project owner immediately
4. Follow emergency recovery procedures in `/docs/troubleshooting/semantic-release-recovery.md`

### File Management Rules

**CRITICAL: File Deletion Policy**

- **NEVER delete any files without explicit permission**
- **ALWAYS ask for approval before removing any file**
- **This includes temporary files, old code, or seemingly unused files**
- When refactoring or cleaning up, list files to be deleted and wait for confirmation

**CRITICAL: Documentation Organization Policy**

- **KEEP root directory clean** - Only essential files should remain in root
- **Essential root files only:**
  - `README.md` - Project introduction and quick start
  - `CHANGELOG.md` - Release notes and version history
  - `CLAUDE.md` - Instructions for AI development assistant
  - `PROJECT_STATUS.md` - Current development status
  - `package.json`, `tsconfig.json` - Core configuration files
- **Move documentation to organized structure:**
  - Feature docs â†’ `docs/features/[feature-name]/`
  - Architecture docs â†’ `docs/architecture/`
  - Development guides â†’ `docs/development/`
  - Infrastructure guides â†’ `docs/infrastructure/`
- **NEVER create standalone .md files in root** without specific justification

### PROJECT_STATUS.md Update Policy (MANDATORY)

**ğŸš¨ CRITICAL: Keep Summary & Recommendations section updated and visible at the top**

**Why This Matters:**

- `PROJECT_STATUS.md` is the session recovery document
- New sessions append to the file, pushing content down
- **Summary & Recommendations must stay at the top** for quick access
- This section shows current project health and next steps at a glance

**MANDATORY Rules:**

1. **Location**: Summary & Recommendations section is located **immediately after "Implemented Features"** section
2. **Update Frequency**: Update this section **every time you complete a major task or session**
3. **What to Update**:
   - âœ… "What's Working Well" - Add new completed features
   - ğŸ¯ "Recommended Next Steps" - Update priorities based on current status
   - ğŸ“Š "Project Health Status" - Update metrics if changed
   - ğŸ‰ "Current Project Status" - Update feature counts and capabilities

**When to Update:**

- âœ… After completing a feature
- âœ… After significant architectural changes
- âœ… After publishing new versions (CRUD Generator, etc.)
- âœ… When starting a new major feature
- âœ… At the end of each session if significant progress made

**How to Update:**

```bash
# 1. Open PROJECT_STATUS.md
# 2. Scroll to "Summary & Recommendations" section (near top)
# 3. Update relevant subsections
# 4. Update "Last Updated" date at bottom of section
# 5. Commit changes with descriptive message
```

**Important Note:**

- âŒ **DO NOT** duplicate Summary & Recommendations at the bottom
- âœ… **KEEP IT** at the top after "Implemented Features" section
- âœ… **ADD NOTE** at bottom: "_ğŸ“Œ Note: Summary & Recommendations section is at the top of this file_"

**Example Commit Messages:**

- `docs(status): update project health status after CRUD generator v2.1.0 release`
- `docs(status): add new completed features to recommendations`
- `docs(status): update next steps priorities`

### Feature Documentation Policy (MANDATORY)

**ğŸš¨ ALL new features MUST have comprehensive documentation - NO EXCEPTIONS**

**For EVERY new feature, create a complete documentation package in `/docs/features/[feature-name]/`:**

1. **README.md** - Feature overview and quick start guide
2. **USER_GUIDE.md** - End-user guide for using the feature
3. **DEVELOPER_GUIDE.md** - Technical guide for developers
4. **API_REFERENCE.md** - Complete API documentation (if applicable)
5. **ARCHITECTURE.md** - System architecture and design decisions
6. **DEPLOYMENT_GUIDE.md** - Production deployment instructions
7. **TROUBLESHOOTING.md** - Common issues and solutions
8. **DOCUMENTATION_INDEX.md** - Navigation & learning guide

**Documentation Standards:**

- **Professional grade** - Suitable for enterprise environments
- **Multiple audiences** - End users, developers, administrators, architects
- **Practical examples** - Working code examples and step-by-step guides
- **Complete coverage** - All aspects of the feature documented
- **Cross-referenced** - Easy navigation between related documents
- **Maintainable** - Well-organized for future updates

**Example Reference:** See `/docs/features/activity-tracking/` for the complete documentation standard that should be followed for all new features.

### Schema Standards (MANDATORY)

**ğŸš¨ ALL API routes MUST use TypeBox schemas - NO EXCEPTIONS**

- **See [TypeBox Schema Standard](./docs/05c-typebox-schema-standard.md) for implementation**
- **TypeBox provides both runtime validation and TypeScript types**
- **Use base schemas from `/src/schemas/base.schemas.ts`**
- **Register schemas via schema registry**

### Type Safety Policy (MANDATORY)

**ğŸš¨ NEVER use `any` or type assertions without proper schemas - NO EXCEPTIONS**

**Full Type Flow Required:**

1. **Schema Definition**: Create TypeBox schema in `*.schemas.ts`
2. **Type Export**: Export `Static<typeof Schema>` type
3. **Route Registration**: Use schema in routes with proper imports
4. **Controller Typing**: Use exported types in FastifyRequest generics
5. **OpenAPI Documentation**: Schemas automatically generate OpenAPI spec

**Example Flow:**

```typescript
// 1. Schema definition
export const DeleteQuerySchema = Type.Object({
  force: Type.Optional(Type.Boolean())
});

// 2. Type export
export type DeleteQuery = Static<typeof DeleteQuerySchema>;

// 3. Route registration
querystring: DeleteQuerySchema,

// 4. Controller typing
request: FastifyRequest<{
  Params: FileIdParam;
  Querystring: DeleteQuery;
}>

// 5. Type-safe access
const force = request.query.force || false;
```

**Forbidden Patterns:**

- `request.query as any`
- `request.query as { field?: string }`
- Modifying TypeScript types without updating schemas
- Type assertions without schema validation

### UUID Validation Policy (MANDATORY)

**ğŸš¨ UUID fields MUST be validated to prevent PostgreSQL casting errors - NO EXCEPTIONS**

**Built-in UUID Protection:**

- **Automatic Validation**: All repositories inherit UUID validation from BaseRepository
- **Smart Detection**: Auto-detects UUID fields based on patterns (`*_id`, `id`, `*uuid*`)
- **PostgreSQL Error Prevention**: Invalid UUIDs filtered out before database queries
- **Multiple Strategies**: STRICT (400 errors), GRACEFUL (filter invalid), WARN (log + continue)

**CRUD Generator Integration:**

```typescript
// Generated repositories automatically include UUID validation
export class ArticlesRepository extends BaseRepository<Articles, CreateArticles, UpdateArticles> {
  constructor(knex: Knex) {
    super(
      knex,
      'articles',
      [...searchFields],
      ['id', 'author_id'], // ğŸ›¡ï¸ Explicit UUID fields for validation
    );
  }
}
```

**Manual Configuration:**

```typescript
// For custom repositories, declare UUID fields explicitly
repository.setUUIDFields(['user_id', 'category_id']);

// Configure validation strategy
repository.setUUIDValidationConfig({
  strategy: UUIDValidationStrategy.STRICT, // Throw 400 errors
  allowAnyVersion: true,
  logInvalidAttempts: true,
});
```

**Benefits:**

- **No PostgreSQL Errors**: Prevents `invalid input syntax for type uuid` errors
- **Better UX**: Invalid UUIDs handled gracefully instead of 500 errors
- **Automatic Protection**: All new CRUD modules get UUID validation by default
- **Zero Configuration**: Works automatically with naming conventions

### Universal Development Standard (MANDATORY)

**ğŸš¨ MUST follow Universal Full-Stack Standard for ALL feature development - NO EXCEPTIONS**

See **[Universal Full-Stack Standard](./docs/development/universal-fullstack-standard.md)** for complete database-first development workflow that must be followed for every feature to prevent integration bugs.

### Feature Development Standard (MANDATORY)

**ğŸš¨ MUST follow Feature Development Standard for EVERY feature - NO EXCEPTIONS**

- **See [Feature Development Standard](./docs/development/feature-development-standard.md)** for complete feature lifecycle from planning to completion
- **ALWAYS create feature documentation before coding** using templates from `docs/features/templates/`
- **Reserve resources** in [Resource Registry](./docs/features/RESOURCE_REGISTRY.md) before starting development
- **Follow [Multi-Feature Workflow](./docs/development/multi-feature-workflow.md)** when multiple features are being developed simultaneously
- **Update progress daily** in feature PROGRESS.md files
- **Check [Feature Status Dashboard](./docs/features/README.md)** for coordination with other developers

### API-First Development Policy (MANDATORY)

**ğŸš¨ MUST follow API-First workflow for ALL feature development - NO EXCEPTIONS**

**Before implementing ANY frontend component or making API calls:**

1. **ğŸ“‹ CHECK API SPEC** - Review `docs/features/[feature]/API_CONTRACTS.md` thoroughly
2. **ğŸ” VERIFY ENDPOINTS** - Confirm backend routes match the documented API spec exactly
3. **ğŸ§ª TEST API ENDPOINTS** - Test actual API calls before implementing frontend logic
4. **ğŸ“ VALIDATE SCHEMAS** - Ensure request/response schemas match TypeBox definitions
5. **ğŸ”„ UPDATE DOCUMENTATION** - Update API docs if any changes are needed

**API Spec Verification Rules:**

- **NEVER assume endpoint URLs** - Always check the documented API contracts first
- **NEVER implement frontend without backend API** - API must exist and work before frontend
- **NEVER guess schema formats** - Use exact TypeBox schemas from documentation
- **ALWAYS test with real data** - Use actual API responses, not mock data

**If API spec missing or incorrect:**

1. **STOP development immediately**
2. **Ask user:** "API spec for [feature] is missing/incorrect. Should I update the spec or fix the implementation?"
3. **Wait for explicit direction**
4. **Update either spec or implementation as instructed**

**Example API-First Workflow:**

```bash
# 1. Check feature API contracts
cat docs/features/user-profile/API_CONTRACTS.md

# 2. Verify backend routes exist
grep -r "GET /api/profile/preferences" apps/api/src/

# 3. Test API endpoint
curl -X GET http://localhost:3333/api/profile/preferences

# 4. Only then implement frontend service
```

### Quality Assurance Workflow (MANDATORY)

**ğŸš¨ MUST run QA Checklist after every code change - NO EXCEPTIONS**

See **[QA Checklist](./docs/development/qa-checklist.md)** for complete quality assurance steps that must be performed before every commit.

### Testing Workflow (MANDATORY)

**ğŸš¨ ALWAYS follow this workflow when writing tests - NO EXCEPTIONS**

**Before writing ANY test:**

1. **ğŸ“‹ Check existing schemas** - Review `*.schemas.ts` files for the module you're testing
2. **ğŸ” Verify request/response formats** - Ensure test data matches schema exactly
3. **ğŸ—ï¸ Check test app helper** - Ensure all required plugins are registered in test environment
4. **ğŸ“Š Compare with main app** - Verify test setup mirrors production plugin registration order

**Test Data Rules:**

- **NEVER guess request formats** - Always use schema definitions
- **Match schemas exactly** - Include only fields defined in request schemas
- **Use schema-based factories** - Create separate functions for API-valid test data
- **Check plugin registration** - Ensure test app includes ALL plugins the route needs

**Example Test Workflow:**

```typescript
// 1. Check schema first
import { RegisterRequestSchema } from '../auth.schemas';

// 2. Create API-compatible test data
function createRegisterRequestData() {
  return {
    email: 'test@example.com',
    username: 'testuser',
    password: 'testpass123',
    firstName: 'Test',
    lastName: 'User',
    // âŒ Don't include: role, status, emailVerified (not in schema)
  };
}

// 3. Verify test app helper includes ALL required plugins
```

**à¸œà¸´à¸”à¹à¸¥à¹‰à¸§à¸•à¹‰à¸­à¸‡à¹à¸à¹‰à¸—à¸±à¸™à¸—à¸µ - à¸«à¹‰à¸²à¸¡à¹€à¸”à¸²!**

## ğŸ”´ IMPORTANT: This project uses PNPM, not NPM or Yarn

**Always use `pnpm` commands, never use `npm` or `yarn` commands for dependencies**

## ğŸ—ï¸ Multi-Instance Development Setup

**When working on multiple features simultaneously (cloned repos):**

### ğŸ“‹ Quick Setup (One Command)

```bash
# Auto-configure ports and containers based on folder name
pnpm setup
# This runs: setup-env.sh + docker-compose up + migrations + seeds
```

### ğŸ”§ Manual Setup Steps

```bash
# 1. Configure instance-specific environment
pnpm run setup:env

# 2. Start services with unique ports/containers
pnpm run docker:up

# 3. Initialize database
pnpm run db:migrate && pnpm run db:seed
```

### ğŸ“Š Port Assignment Strategy

- **Main repo (aegisx-starter)**: Default ports (5432, 6380, 3333, 4200)
- **Feature repos (aegisx-starter-{name})**: Auto-assigned unique ports
- **Examples**:
  - `aegisx-starter-mpv` â†’ PostgreSQL: 5433, Redis: 6381, API: 3334
  - `aegisx-starter-rbac` â†’ PostgreSQL: 5434, Redis: 6382, API: 3335

### ğŸ› ï¸ Instance Management Commands

```bash
# View all instances and their ports
./scripts/port-manager.sh list

# Check for port conflicts
./scripts/port-manager.sh conflicts

# Stop specific instance
./scripts/port-manager.sh stop aegisx-starter-mpv

# Stop all instances
./scripts/port-manager.sh stop-all

# Show running services
./scripts/port-manager.sh running

# Clean up unused containers/volumes
./scripts/port-manager.sh cleanup
```

### ğŸ¯ Benefits

- âœ… **Isolated environments** - Each feature has its own database
- âœ… **No port conflicts** - Auto-assigned unique ports
- âœ… **Parallel development** - Work on multiple features simultaneously
- âœ… **Easy switching** - Stop/start instances as needed
- âœ… **Consistent naming** - Folder name determines configuration

## Quick Navigation

### ğŸš€ Start Here

- **[ğŸ“– Getting Started](./docs/getting-started/getting-started.md)** - **à¸­à¹ˆà¸²à¸™à¸à¹ˆà¸­à¸™à¹€à¸£à¸´à¹ˆà¸¡à¸‡à¸²à¸™! Git workflow & rules**

### Development Resources

- **[ğŸš¨ Current Project Status](./PROJECT_STATUS.md)** - Session recovery & current progress
- **[ğŸ“š Complete Documentation](./docs/)** - Organized documentation hub
- **[ğŸ“Š Feature Status Dashboard](./docs/features/README.md)** - Central feature development tracking
- **[ğŸ“‹ Feature Development Standard](./docs/development/feature-development-standard.md)** - **MANDATORY** feature lifecycle
- **[ğŸ¤ Multi-Feature Workflow](./docs/development/multi-feature-workflow.md)** - Parallel development coordination
- **[ğŸ“ Resource Registry](./docs/features/RESOURCE_REGISTRY.md)** - Reserve resources to prevent conflicts
- **[ğŸ“Š Feature Tracking System](./docs/development/feature-tracking.md)** - Track development progress
- **[ğŸš€ Quick Commands](./docs/development/quick-commands.md)** - Claude command reference (/feature, /status, etc.)
- **[ğŸ—ï¸ Project Setup](./docs/getting-started/project-setup.md)** - Bootstrap guide
- **[ğŸ”„ Development Workflow](./docs/development/development-workflow.md)** - Step-by-step workflows
- **[ğŸ¯ API-First Workflow](./docs/development/api-first-workflow.md)** - Recommended development approach
- **[ğŸ›ï¸ Architecture](./docs/architecture/architecture-overview.md)** - Frontend/Backend patterns
- **[ğŸ§ª Testing Strategy](./docs/testing/testing-strategy.md)** - E2E with Playwright MCP
- **[ğŸš€ Deployment](./docs/infrastructure/deployment.md)** - Docker + CI/CD
- **[ğŸ¤– MCP Integration](./docs/development/mcp-integration.md)** - Nx MCP & Playwright MCP usage
- **[ğŸ“‹ All Commands Reference](./docs/references/claude-commands.md)** - Complete shell command list
- **[ğŸ¤– CRUD Generator](./docs/crud-generator/)** - Automatic CRUD API generation with error handling & validation

## ğŸ“ Recent Development Sessions

> **ğŸ“Œ For complete session history and details, see [PROJECT_STATUS.md](./PROJECT_STATUS.md) Â§ Recent Development Sessions**

### Current Status (Session 46 - 2025-10-28)

**Latest Cleanup:**

- âœ… **Theme System Removed** - 9 files deleted (themes module not needed)
- âœ… **ALL Business Features Removed** - 72 files deleted (books, authors, budgets, comprehensive-tests)
- âœ… **Unused Files Cleaned** - Scripts, test directories, build output removed
- âœ… **Repository Clean Slate** - Empty modules/ and features/ ready for HIS & Inventory
- âœ… **Total Cleanup** - 89 files deleted, 4 commits, all pushed successfully

**Documentation & Release:**

- âœ… **Documentation Updated** - PROJECT_STATUS.md and CLAUDE.md updated with Session 46 summary (Commit: `a884692`)
- âœ… **Merged to Main** - All changes merged to main branch with `--no-ff` (Merge commit: `ee448c3`)
- âœ… **Release Triggered** - GitHub Actions automated release workflow started
- ğŸ“Š **Merge Statistics**: 400 files changed, +38,755/-54,170 lines (Net: -15,415 lines cleaner!)
- ğŸŸ¢ **Status**: Awaiting GitHub Actions to complete v1.x.x release

**Repository Status:**

- 14 core backend modules (only essential infrastructure)
- 10 core frontend features (only core platform)
- Empty `apps/api/src/modules/` - Ready for HIS modules
- Empty `apps/web/src/app/features/` - Ready for HIS features
- CRUD Generator verified working and ready
- Clean repository ready for HIS and Inventory development

### Previous Status (Session 44 - 2025-10-28)

**Latest Updates:**

- âœ… **CRUD Generator v2.1.0** - Released with HIS Mode (data accuracy first)
- âœ… **Repository Cleanup** - 143 files deleted, 58,512 lines removed
- âœ… **Communication Guide** - Exact phrases for version releases documented

**Key Learning from Release Process:**

- Tags for npm packages belong in the **PACKAGE repository**, not main monorepo
- Use git subtree to sync `libs/aegisx-crud-generator/` to separate crud-generator repo
- Clear communication phrases prevent mistakes (see "CRUD Generator Version Release & NPM Publishing" section below)

## ğŸš¨ CRITICAL: CRUD Generator Git Workflow

**âš ï¸ libs/aegisx-crud-generator/ is synced to separate repository**

**MANDATORY Steps After Making Changes to CRUD Generator:**

```bash
# 1. Commit changes in main monorepo
git add libs/aegisx-crud-generator/
git commit -m "docs(crud-generator): update documentation"

# 2. âš ï¸ CRITICAL: Sync to separate crud-generator repository
./libs/aegisx-crud-generator/sync-to-repo.sh develop

# 3. Push main monorepo
git push origin develop

# 4. (Optional) Publish to NPM if package.json version changed
cd libs/aegisx-crud-generator
npm publish
```

**Git Subtree Commands:**

```bash
# Sync to separate repository (most common)
./libs/aegisx-crud-generator/sync-to-repo.sh develop

# Manual sync (if script unavailable)
git subtree push --prefix=libs/aegisx-crud-generator \
  git@github.com:aegisx-platform/crud-generator.git develop

# Pull updates from separate repository (rare)
git subtree pull --prefix=libs/aegisx-crud-generator \
  git@github.com:aegisx-platform/crud-generator.git develop --squash
```

**âš ï¸ DO NOT FORGET** the git subtree push or changes won't appear in the separate crud-generator repository!

**Why This Matters:**

- `libs/aegisx-crud-generator/` is published as standalone NPM package
- Separate repository: https://github.com/aegisx-platform/crud-generator
- Main monorepo is source of truth, must sync to separate repo
- NPM package is built from separate repository

## ğŸš¨ CRITICAL: CRUD Generator Version Release & NPM Publishing

**âš ï¸ NEVER create version tags in main aegisx-starter repository!**

**Tags MUST be created ONLY in the separate crud-generator repository**

### ğŸ“¦ How to Communicate with Claude

**Use these EXACT phrases to avoid confusion:**

| What You Want    | Say This to Claude                      | What Claude Will Do                                                                      |
| ---------------- | --------------------------------------- | ---------------------------------------------------------------------------------------- |
| **Version Bump** | "à¸­à¸­à¸ version CRUD generator à¹€à¸›à¹‡à¸™ X.X.X" | 1. Bump package.json version<br>2. Commit in main repo<br>3. Sync to crud-generator repo |
| **Tag Creation** | "à¸ªà¸£à¹‰à¸²à¸‡ tag CRUD generator vX.X.X"       | Create tag in **crud-generator repo only** (NOT main repo)                               |
| **NPM Publish**  | "publish CRUD generator à¹„à¸› npm"         | User provides OTP, Claude runs publish.sh                                                |
| **Full Release** | "release CRUD generator vX.X.X"         | Complete workflow: bump â†’ commit â†’ sync â†’ tag â†’ npm publish                              |
| **Sync Only**    | "sync CRUD generator"                   | Git subtree push to crud-generator repo                                                  |

### ğŸ”„ Complete Release Workflow

**When you say: "release CRUD generator v2.1.0"**

```bash
# Step 1: Version Bump & Commit (in main repo)
cd libs/aegisx-crud-generator
# Edit package.json: "version": "2.1.0"
git add .
git commit -m "chore(crud-generator): bump version to 2.1.0"
git push origin develop

# Step 2: Sync to Separate Repository
cd /path/to/main/repo
./libs/aegisx-crud-generator/sync-to-repo.sh develop
# OR manual:
# git subtree push --prefix=libs/aegisx-crud-generator \
#   git@github.com:aegisx-platform/crud-generator.git develop

# Step 3: Create Tag in CRUD Generator Repo (NOT main repo!)
git push git@github.com:aegisx-platform/crud-generator.git \
  <commit-hash>:refs/tags/v2.1.0

# Step 4: Publish to NPM (user provides OTP)
cd libs/aegisx-crud-generator
./publish.sh <OTP-CODE>
```

### âš ï¸ CRITICAL RULES

**DO:**

- âœ… Create tags in **crud-generator repository** (`git@github.com:aegisx-platform/crud-generator.git`)
- âœ… Always sync to separate repo before creating tags
- âœ… Wait for user to provide OTP before npm publish
- âœ… Use semantic versioning (major.minor.patch)

**DON'T:**

- âŒ NEVER create version tags in main aegisx-starter repository
- âŒ NEVER create tags before syncing to separate repo
- âŒ NEVER publish without user's explicit OTP code
- âŒ NEVER skip git subtree sync step

### ğŸ¯ Why This Architecture?

```
Main Monorepo (aegisx-starter)
â””â”€â”€ libs/aegisx-crud-generator/
    â”‚
    â”œâ”€ git subtree push â”€â”€â†’ Separate Repo (crud-generator)
    â”‚                       â””â”€â”€ NPM Package Source
    â”‚                           â”œâ”€â”€ Tags (v2.1.0, v2.0.1, etc.)
    â”‚                           â””â”€â”€ npm publish â†’ registry.npmjs.org
    â”‚
    â””â”€ âŒ NO TAGS HERE! Tags belong in separate repo only
```

**Benefits:**

1. Main repo stays clean (no package-specific tags)
2. NPM package has its own version history
3. Separation of concerns: monorepo vs. published package
4. Easy to manage multiple packages in future

### ğŸ“‹ Quick Reference Examples

**Example 1: Full Release**

```
User: "à¸­à¸­à¸ version CRUD generator 2.1.0 à¹à¸¥à¹‰à¸§ publish"
Claude:
1. âœ… Bump package.json to 2.1.0
2. âœ… Commit to main repo
3. âœ… Sync to crud-generator repo
4. âœ… Create tag v2.1.0 in crud-generator repo
5. â¸ï¸ Wait for user OTP
User: "OTP: 123456"
Claude: âœ… Publish to npm
```

**Example 2: Sync Only**

```
User: "sync CRUD generator"
Claude: âœ… Git subtree push to crud-generator repo
```

**Example 3: Tag Only**

```
User: "à¸ªà¸£à¹‰à¸²à¸‡ tag v2.1.0 à¹ƒà¸«à¹‰ CRUD generator"
Claude: âœ… Create tag in crud-generator repo (NOT main repo)
```

## ğŸ¤– CRUD Generator Quick Commands

### Basic Generation

```bash
# Generate basic CRUD (no import, no events)
pnpm aegisx-crud books --package

# Generate with import functionality
pnpm aegisx-crud budgets --package --with-import

# Generate with WebSocket events
pnpm aegisx-crud notifications --package --with-events

# Generate with both import and events
pnpm aegisx-crud products --package --with-import --with-events
```

### Advanced Options

```bash
# Dry run (preview without creating files)
pnpm aegisx-crud articles --package --dry-run

# Force overwrite existing files
pnpm aegisx-crud users --package --force

# Combine all flags
pnpm aegisx-crud inventory --package --with-import --with-events --force
```

### Common Workflows

**1. New Feature with Import:**

```bash
# Generate CRUD with import dialog
pnpm aegisx-crud budgets --package --with-import

# Files created:
# - Backend: controller, service, repository, routes, schemas, tests
# - Frontend: list, create/edit/view dialogs, import dialog, service, types
# - Database: Migration file
```

**2. Real-Time Feature with Events:**

```bash
# Generate CRUD with WebSocket events
pnpm aegisx-crud notifications --package --with-events

# Backend includes:
# - EventService integration
# - Event emission on create/update/delete
# - Bulk operation events (bulk_started, bulk_progress, bulk_completed)
```

**3. Regenerate Existing Feature:**

```bash
# Review changes first
pnpm aegisx-crud books --package --dry-run

# Force regenerate if satisfied
pnpm aegisx-crud books --package --force
```

### Flag Reference

| Flag            | Description                                | Use Case                          |
| --------------- | ------------------------------------------ | --------------------------------- |
| `--package`     | Use `.crudgen.json` config                 | âœ… ALWAYS use this flag           |
| `--with-import` | Add import dialog + backend import service | Bulk data import features         |
| `--with-events` | Add WebSocket real-time events             | Live updates, notifications       |
| `--dry-run`     | Preview changes without creating files     | Review before generation          |
| `--force`       | Overwrite existing files                   | Regenerate after template updates |

**ğŸ“š Complete Documentation:** See `docs/crud-generator/` for comprehensive guides

### CI/CD & DevOps

- **[ğŸ”„ Git Flow & Release](./docs/infrastructure/git-flow-release-guide.md)** - Branch strategy & release process
- **[ğŸ“¦ Automated Versioning](./docs/infrastructure/automated-versioning-guide.md)** - Conventional commits & changelog
- **[ğŸ³ Monorepo Docker Guide](./docs/infrastructure/monorepo-docker-guide.md)** - Docker management for monorepo
- **[ğŸš€ CI/CD Quick Start](./docs/infrastructure/quick-start-cicd.md)** - GitHub Actions setup & usage
- **[ğŸ“š CI/CD Complete Setup](./docs/infrastructure/ci-cd-setup.md)** - Detailed CI/CD documentation

## ğŸ› ï¸ Technology Stack

- **Frontend**: Angular 19+ with Signals, Angular Material + TailwindCSS
- **Backend**: Fastify 4+ with TypeScript
- **Database**: PostgreSQL 15+ with Knex.js
- **Monorepo**: Nx with Yarn workspaces
- **Testing**: Jest + Playwright + MCP
- **Infrastructure**: Docker + GitHub Actions + GitHub Container Registry

## ğŸƒâ€â™‚ï¸ Quick Start Commands

```bash
# Install dependencies (âš ï¸ USE PNPM, NOT NPM OR YARN!)
pnpm install

# Set up environment
cp .env.example .env

# Start databases
pnpm run docker:up

# Run migrations
npm run db:migrate

# Seed database
npm run db:seed

# Start development
nx run-many --target=serve --projects=api,web
```

## ğŸ“‹ Most Used Commands

| Command       | Description                      | Actual Command                                  |
| ------------- | -------------------------------- | ----------------------------------------------- |
| **Install**   | Install dependencies (USE PNPM!) | `pnpm install`                                  |
| **DB Setup**  | Run migrations & seeds           | `pnpm db:migrate && pnpm db:seed`               |
| **Develop**   | Start dev servers                | `nx run-many --target=serve --projects=api,web` |
| **Test**      | Run all tests                    | `nx run-many --target=test --all`               |
| **E2E**       | Run E2E tests                    | `nx e2e e2e`                                    |
| **Build**     | Build for production             | `nx run-many --target=build --all`              |
| **Docker**    | Start services                   | `pnpm run docker:up`                            |
| **Docker PS** | Show current instance containers | `pnpm run docker:ps`                            |

## ğŸš€ Feature Development Commands

| Command       | Description              | Actual Command                                              |
| ------------- | ------------------------ | ----------------------------------------------------------- |
| **Start**     | Start new feature        | `./scripts/feature-toolkit.sh start [name] [priority]`      |
| **Status**    | Check feature progress   | `./scripts/feature-toolkit.sh status [name]`                |
| **Progress**  | Update feature progress  | `./scripts/feature-toolkit.sh progress [name] "[task]" [%]` |
| **Complete**  | Mark feature complete    | `./scripts/feature-toolkit.sh complete [name]`              |
| **Dashboard** | Show all features        | `./scripts/feature-toolkit.sh dashboard`                    |
| **Conflicts** | Check resource conflicts | `./scripts/feature-toolkit.sh conflicts [name]`             |

## ğŸ³ Multi-Instance Docker Commands

| Command    | Description                   | Actual Command          |
| ---------- | ----------------------------- | ----------------------- |
| **Up**     | Start instance services       | `pnpm run docker:up`    |
| **Down**   | Stop instance services        | `pnpm run docker:down`  |
| **Status** | Show instance containers      | `pnpm run docker:ps`    |
| **Reset**  | Reset instance (down+up+data) | `pnpm run docker:reset` |

### Quick Aliases (add to ~/.bashrc or ~/.zshrc)

```bash
source .feature-aliases  # Load feature command shortcuts
# Then use: fs, fstat, fprog, fcomp, fdash
```

## ğŸš€ Project Structure

```
aegisx-starter/
â”œâ”€â”€ apps/                      # Applications
â”‚   â”œâ”€â”€ api/                   # âœ… Fastify backend
â”‚   â”œâ”€â”€ web/                   # âœ… Angular web app
â”‚   â””â”€â”€ admin/                 # âœ… Angular admin panel
â”œâ”€â”€ docs/                      # âœ… Complete documentation
â”‚   â”œâ”€â”€ 01-feature-tracking.md
â”‚   â”œâ”€â”€ 02-quick-commands.md
â”‚   â”œâ”€â”€ 04a-api-first-workflow.md
â”‚   â””â”€â”€ ...
â”œâ”€â”€ docker-compose.yml         # âœ… Development environment
â”œâ”€â”€ package.json               # âœ… NPM scripts
â””â”€â”€ nx.json                    # âœ… Nx configuration
```

## ğŸ¯ Development Philosophy

1. **API-First**: Design OpenAPI spec before implementation (See [API-First Workflow Guide](./docs/04a-api-first-workflow.md))
2. **Feature Modules**: Organized, testable, maintainable code
3. **E2E Testing**: Visual verification with Playwright MCP
4. **Progress Tracking**: Always maintain development status
5. **Quality Gates**: Unit â†’ Integration â†’ E2E â†’ Visual tests
6. **Signals-First**: Angular state management with Signals
7. **Type Safety**: Full TypeScript with strict mode
8. **Contract-Driven**: Frontend and Backend develop from same spec
9. **Alignment Checks**: Continuous validation of frontend-backend compatibility

---

_For complete documentation, see individual files in the `docs/` directory._
